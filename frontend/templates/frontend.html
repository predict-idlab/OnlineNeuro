<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Data Plots</title>
    <style>
        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #333;
        }

        h1 {
            text-align: center;
            color: #c02a4e;
        }

        /* Main container for content */
        .content {
            margin-left: 380px; /* Width of the sidebar */
            padding: 20px;
            transition: margin-left 0.3s ease;
        }

        /* Sidebar styling */
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 350px;
            height: 100%;
            background-color: #0e0e0e;
            padding: 15px;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
            transition: width 0.3s ease;
            overflow-y: scroll;
        }
        .sidebar-right {
            position: fixed;
            top: 0;
            right: 0; /* Changed from left: 0 to right: 0 */
            width: 250px;
            height: 100%;
            background-color: #0e0e0e;
            padding: 15px;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.2); /* Adjusted the shadow to appear on the left */
            transition: width 0.3s ease;
        }
        .sidebar::-webkit-scrollbar {
            width: 8px; /* Width of the vertical scrollbar */
            height: 8px; /* Height of the horizontal scrollbar */
        }
        /* Track (background of the scrollbar) */
        .sidebar::-webkit-scrollbar-track {
            background: #1e1e1e; /* Dark background color */
            border-radius: 4px; /* Rounded corners */
        }

        /* Thumb (draggable part of the scrollbar) */
        .sidebar::-webkit-scrollbar-thumb {
            background: #555; /* Gray thumb color */
            border-radius: 4px; /* Rounded corners */
        }

        /* Thumb hover (when hovered over) */
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #888; /* Lighter gray when hovered */
        }
        .header {
            display: flex;
            align-items: center;
        }
        .sidebar h2 {
            color: #6b6b6b;
            margin-top: 0;
        }
        .sidebar experiment-box{
            display: block;
            width: 100%;
            margin-bottom: 10px;
            padding: 10px;
        }
        .sidebar button {
            display: block;
            width: 100%;
            margin-bottom: 10px;
            padding: 10px;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }

        .sidebar button:hover {
            background-color: #e0e0e0; /* Button hover effect */
        }

        /* Style for the select dropdown */
        .styled-select {
            background-color:  #333; /* Black background */
            color: white; /* White text */
            border: none;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            width: 100%; /* Full width */
            text-align: left; /* Align text to left */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s ease;
            appearance: none; /* Remove default select arrow for some browsers */
            -webkit-appearance: none; /* Safari/Chrome */
            -moz-appearance: none; /* Firefox */
        }

        /* Optional: Adding an arrow indicator to match the dropdown button feel */
        .styled-select::after {
            content: 'â–¼';
            position: absolute;
            right: 10px;
            pointer-events: none;
        }

        /* Hover effect to match button hover */
        .styled-select:hover {
            background-color: #333; /* Darker background on hover */
        }
        /* Show the dropdown content when the button is clicked */
        .show {
            display: block;
        }

        /* Toggle button for opening/closing sidebar */
        .sidebar-frame{
            /*margin-bottom: 10px;*/
            padding: 10px;
            border-radius: 5px;
        }
        .toggle-btn {
            position: absolute;
            display: block;
            top: 50px;
            left: 20px;
            font-size: 18px;
            background-color: #c02a4e;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        /* When the sidebar is hidden */
        .sidebar-closed {
            width: 0;
            overflow: hidden;
        }
        /*.content-expanded {*/
        /*    margin-left: 30px;*/
        /*}*/
        iframe {
            display: block;
            margin: 20px auto;
            border: none;
            width: 100%;
            height: 400px;
        }
        .parameter-container{
            display:flex;
            align-items:center;
            margin-bottom: 10px;
            width: 100%;
        }
        .block-title{
            margin-bottom: 5px;
            font-weight: bold;
            font-size: large;
            color: white;
            text-overflow: ellipsis
        }
        .parameter-label{
            text-align: left;
            margin-right: 8px;
            color: white;
            /*white-space: nowrap;*/
            /*width: 100px;*/
            text-overflow: ellipsis
        }
        .inputs-container {
            display: flex;               /* Use flexbox for the inputs */
            flex-direction: column;      /* Stack input rows vertically */
        }
        .inputs-container input{
            width: 45px;
            margin-right: 3px
        }
        .input-row{
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .row-ix{
            width: 40px;
            /*text-align: left;*/
            font-weight: normal;
            color:white;
            align-content: center;
        }
        .dim-label{
            color:white
        }
        .parameter-row{
            display: flex;
            /*flex-wrap: wrap;*/
            gap: 10px;
            max-width: 100%;
        }
        .box {
            width: 100%;
            height: 150px;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
        }
        /* Loading spinner */
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ff3737;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            display: none;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .horizontal-line {
            border: none; /* Remove default border */
            height: 2px; /* Line thickness */
            background-color: #ccc; /* Line color */
            margin-bottom: 8px; /* Space below the line */
        }
        .white-text {
            color: white;
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let globalData
        let optimizableFeatures
        let userDefinedFeatures
        let defaultFeatures

        //let sortedKeys
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const content = document.querySelector('.content');
            sidebar.classList.toggle('sidebar-closed');
            //content.classList.toggle('content-expanded');
        }
        function toggleSidebarRight() {
            const sidebar = document.querySelector('.sidebar-right');
            const content = document.querySelector('.content');
            sidebar.classList.toggle('sidebar-closed');
            //content.classList.toggle('content-expanded');
        }
        function showSpinner(show) {
            document.getElementById('spinner').style.display = show ? 'block' : 'none';
        }

        function cleanFinalParameters(params) {
            const cleanedParams = {};

            Object.entries(params).forEach(([key, subStruct]) => {
                const hasMinMax = 'min_value' in subStruct && 'max_value' in subStruct;
                const values = subStruct.value || [];
                const minValues = subStruct.min_value || [];
                const maxValues = subStruct.max_value || [];

                if (!hasMinMax) {
                    // Scenario 1: Only 'value' key exists
                    const nonNullValues = Array.isArray(values)
                        ? values.filter(val => val !== null)
                        : (values !== null ? [values] : []);
                    if (nonNullValues.length > 0){
                        cleanedParams[key] = nonNullValues
                    }
                } else {
                    // Scenario 2: 'value', 'min_value', and 'max_value' keys exist
                    const maxLength = Math.max(values.length, minValues.length, maxValues.length);
                    const filledValues = new Array(maxLength).fill(0);
                    const filledMinValues = new Array(maxLength).fill(0);
                    const filledMaxValues = new Array(maxLength).fill(0);

                    for (let i = 0; i < maxLength; i++) {
                        filledValues[i] = values[i] !== undefined ? values[i] : 0;
                        filledMinValues[i] = minValues[i] !== undefined ? minValues[i] : 0;
                        filledMaxValues[i] = maxValues[i] !== undefined ? maxValues[i] : 0;
                    }

                    cleanedParams[key] = {
                        value: filledValues,
                        min_value: filledMinValues,
                        max_value: filledMaxValues,
                    };
                }
            });

            return cleanedParams;
        }

        function restructureParameters(data) {

            const finalParameters = {};
            Object.entries(data).forEach(([key, value]) => {
                const cleanedKey = key
                    .replace(/^param_/, "") // Remove "param_"
                    .replace(/_\d+$/, "") // Remove the index (_n)
                    .replace(/_(min|max)$/, "")    // Remove "_min" or "_max" if present
                    .replace(/_[a-zA-Z]$/, "");    // Remove the last "_x" (it would be a dimension)

                const typeMatch = key.match(/_(min|max)_/); // Check if key ends with "_min" or "_max"

                const type = typeMatch ? `${typeMatch[1]}_value` : "value"; // Set the key type
                const ixMatch = key.match(/_(\d+)$/);
                const ix = ixMatch ? parseInt(ixMatch[1], 10) : null; // Extract the index as an integer, or null if none

                if (!finalParameters[cleanedKey]) {
                    finalParameters[cleanedKey] = {};
                }
                if (!finalParameters[cleanedKey][type]) {
                    finalParameters[cleanedKey][type] = [];
                }

                let dimensions = null
                if (cleanedKey in globalData) {
                    dimensions = globalData[cleanedKey].dimensions || []
                } else {
                    // We assume pulse parameters don't have dimensions
                    dimensions = []
                }

                if (dimensions.length == 0) {
                    if (ix !== null) {
                        finalParameters[cleanedKey][type][ix] = value;
                    } else {
                        finalParameters[cleanedKey][type] = value;
                    }
                } else{
                    const dimensionMatch = key.match(/_([a-zA-Z])_\d+$/); // Matches the dimension (_x_, _y_, etc.)
                    const dimension = dimensionMatch[1];
                    const dimensionIndex = dimensions.indexOf(dimension);

                    if (!finalParameters[cleanedKey][type][dimensionIndex]){
                        finalParameters[cleanedKey][type][dimensionIndex] = []
                    }
                    finalParameters[cleanedKey][type][dimensionIndex][ix] = value;

                }
            });
            console.log("Final Param")
            console.log(finalParameters)
            const cleanParameters = cleanFinalParameters(finalParameters)
            console.log(cleanParameters)
            Object.entries(defaultFeatures).forEach(([key, value]) => {
                if (!(key in finalParameters)) {
                    console.log("Key was missing, added,", key)
                    cleanParameters[key] = value;
                }
            });

            return cleanParameters;
        }

        function collectInputs(elementId){
            const sidebarFrame = document.getElementById(elementId);
            const inputs = sidebarFrame.querySelectorAll('input');

            // Create an object to store the parameter values
            const parameters = {};
            inputs.forEach(input => {
                if (input.type === 'checkbox') {
                    // For checkboxes, store true or false depending on whether it's checked
                    parameters[input.id] = input.checked;
                } else {
                    // For other inputs, store the value
                    parameters[input.id] = input.value;
                }
            });
            const selects = sidebarFrame.querySelectorAll('select');
            selects.forEach(select =>{
                parameters[select.id] = select.options[select.selectedIndex].value;  // Get selected option value
            });
            return parameters
        }

        async function startExperiment() {
            showSpinner(true);
            //const experimentSelector = document.getElementById('experiment');
            //const selectedExperiment = experimentSelector.value;
            // Collect all inputs from the "sidebar-frame" div
            let parameters = collectInputs('sidebar-left')
            console.log("Collected params")
            console.log(parameters)
            parameters = restructureParameters(parameters)
            await createIframes()

            try {
                const response = await fetch('/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(parameters),
                });
                console.log("Package sent")
                console.log(parameters)

                const data = await response.json();
                console.log(data);

            } catch(error) {
                console.error('Error starting the experiment:', error);
            } finally {
                    // Hide the loading spinner
                    showSpinner(false);
            }
        }

        async function checkStatus() {
            const response = await fetch('/status');
            const data = await response.json();
            console.log(data);
        }

        async function stopExperiment() {
            showSpinner(true);
            const response = await fetch('/stop', { method: 'POST' });
            const data = await response.json();
            console.log(data);
            showSpinner(false);
        }

        // Function to display the selected experiment
        async function fetchExperiments() {
            try {
                const response = await fetch('/experiments');  // API route that returns JSON
                const experiments = await response.json();  // Ensure the response is parsed as JSON
                const experimentSelector = document.getElementById('experiment');

                // Clear existing options (if any)
                experimentSelector.innerHTML = '<option value="">Select Experiment</option>'; // Reset to default option

                // Populate the select element with the fetched experiments
                experiments.forEach(exp => {
                    const option = document.createElement('option');
                    option.value = exp; // Set the value for the option
                    option.innerText = exp; // Display the experiment name
                    experimentSelector.appendChild(option); // Append the option to the select
                });
            } catch (error) {
                console.error("Error fetching data:", error);
            }
        }
        function sortFeatures(features, dataDic) {
            return features.sort((a, b) => {
                if (dataDic[a].type < dataDic[b].type) return -1;
                if (dataDic[a].type > dataDic[b].type) return 1;
                if (a < b) return -1;
                if (a > b) return 1;

                return 0; // if they are equal
            });
        }
        async function updatePulseParameters(){
            const pulseTypes = Array.from(document.querySelectorAll('[id^="param_fun_type_"]')).reduce((acc, input) => {
                const match = input.id.match(/_(\d+)$/); // Extract the number at the end of the ID
                if (match) {
                    const number = match[1]; // Get the matched number
                    acc[number] = input.value; // Assign the input value to the corresponding number
                }
                return acc; // Return the accumulator for the next iteration
            }, {});
            if (Object.keys(pulseTypes).length == 0){
                return;
            }
            let configs = [];
            await Promise.all(Object.values(pulseTypes).map(async pt => { // Use Object.values to iterate
                const response = await fetch('/get_fun_parameters', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({function: pt}) // Pass the experiment as JSON in the body
                });
                if (!response.ok) {
                    console.error("Error fetching parameters:", response.statusText);
                    return;
                }
                let this_config = await response.json()
                configs.push(this_config)
                }));

            for (let i = 0; i < configs.length; i++) {
                const pulseConfig = configs[i];
                let pulse_key = `pulse_${i}`
                globalData[pulse_key] = {}; // Initialize as an empty object if it doesn't exist
                Object.keys(pulseConfig).forEach(key => {
                    globalData[pulse_key][key] = pulseConfig[key];
                });
                const currentPulseConfig = globalData[pulse_key];

                let optPulseFeatures = Object.keys(currentPulseConfig).filter(
                    key => currentPulseConfig[key]?.optimizable === true
                );
                let fixPulseFeatures = Object.keys(currentPulseConfig).filter(
                    key => currentPulseConfig[key]?.user_fixed === true
                );

                optPulseFeatures = sortFeatures(optPulseFeatures, currentPulseConfig);
                fixPulseFeatures = sortFeatures(fixPulseFeatures, currentPulseConfig);

                await updateFixedParameters(fixPulseFeatures, currentPulseConfig, 'parameters-container-fixed-pulse', i)
                await updateVariableParameters(optPulseFeatures, currentPulseConfig, 'parameters-container-variable-pulse', i)
            }

            Object.keys(pulseTypes).forEach(number => {
                const input = document.getElementById(`param_fun_type_${number}`);
                input.addEventListener('change', cleanParametersAndUpdate);  // Call the function on change
            });

        }
        async function cleanParametersAndUpdate(){
            // TODO here
            const containerFixedPulse = document.getElementById('parameters-container-fixed-pulse');
            const containerVariablePulse = document.getElementById('parameters-container-variable-pulse');
            containerFixedPulse.innerHTML = ''; //Clear existing parameters
            containerVariablePulse.innerHTML = ''; //Clear existing parameters
            await updatePulseParameters();
        }
        async function updateParameters(){
            await updateFixedParameters(userDefinedFeatures, globalData, 'parameters-container-fixed')
            await updateVariableParameters(optimizableFeatures, globalData , 'parameters-container-rest')
            await updatePulseParameters()
        }

        async function updateElectrodeListeners(){
            const e_pos_inputs = document.querySelectorAll('[id^="param_e_pos"]');
            // e_pos_inputs.forEach(input => {
            //     input.addEventListener('change', drawPlot);
            // });
            const diameterInput = document.getElementById('param_dia') || document.getElementById('param_axon_diameter');
            //TODO uncomment this once the other thing is fixe
            // diameterInput.addEventListener('change', drawPlot);
            // await drawPlot()
        }

        async function addPlotListeners(){
            const experimentSelect = document.getElementById('experiment');
            experimentSelect.addEventListener('change', addPlotListeners);

            const num_electrodes = document.getElementById('param_num_electrodes');
            if (num_electrodes){
                num_electrodes.addEventListener('change', updateElectrodeListeners);
                await updateElectrodeListeners()
            }

        }
        async function experimentChange(){
            await loadParameters()
            if (globalData.hasOwnProperty('num_electrodes')) {
                await addPlotListeners();
                // TODO uncomment
                //drawPlot();
            } else {
                // Clear the canvas if no electrodes are present
                const canvas = document.getElementById('plotCanvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
                console.log("No electrodes to plot.");
            }
        }
        async function loadParameters() {
            const selectedExperiment = document.getElementById('experiment').value;

            if (selectedExperiment===""){
                globalData = false
                const container = document.getElementById('parameters-container-num');
                const fixedTitle = document.getElementById('parameters-header-fixed');
                const variableTitle = document.getElementById('parameters-header-rest');
                const containerFixed = document.getElementById('parameters-container-fixed');
                const containerVariable = document.getElementById('parameters-container-rest');
                const containerFixedPulse = document.getElementById('parameters-container-fixed-pulse');
                const containerVariablePulse = document.getElementById('parameters-container-variable-pulse');

                container.innerHTML = '';  // Clear existing parameters
                fixedTitle.innerHTML = '';  // Clear existing parameters
                variableTitle.innerHTML = '';  // Clear existing parameters
                containerFixed.innerHTML = '';  // Clear existing parameters
                containerVariable.innerHTML = '';  // Clear existing parameters
                containerFixedPulse.innerHTML = ''; //Clear existing parameters
                containerVariablePulse.innerHTML = ''; //Clear existing parameters

            } else{
                const response = await fetch('/get_parameters', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({experiment: selectedExperiment}) // Pass the experiment as JSON in the body
                });

                if (!response.ok) {
                    console.error("Error fetching parameters:", response.statusText);
                    return;
                }

                globalData = await response.json();

                console.log("Received load")
                console.log(globalData)

                const excludeList = ['num_electrodes'];

                optimizableFeatures = Object.keys(globalData).filter(key => globalData[key].optimizable ===true)
                userDefinedFeatures = Object.keys(globalData).filter(key => globalData[key].user_fixed ===true && !excludeList.includes(key))
                // Non GUI values (see the experiment .json for optimizable/user_fixed both false.)
                defaultFeatures = Object.fromEntries(
                    Object.entries(globalData)
                        .filter(([key, value]) => value.user_fixed === false && value.optimizable === false)
                        .map(([key, value]) => [key, value.value]) // Keep only the 'value' key
                );

                console.log("Default features")
                console.log(defaultFeatures)

                optimizableFeatures = sortFeatures(optimizableFeatures, globalData);
                userDefinedFeatures = sortFeatures(userDefinedFeatures, globalData);

                const container = document.getElementById('parameters-container-num');
                const containerFixed = document.getElementById('parameters-container-fixed');
                const containerVariable = document.getElementById('parameters-container-rest');
                const containerFixedPulse = document.getElementById('parameters-container-fixed-pulse');
                const containerVariablePulse = document.getElementById('parameters-container-variable-pulse');

                const fixedTitle = document.getElementById('parameters-header-fixed');
                const variableTitle = document.getElementById('parameters-header-rest');

                fixedTitle.innerText = '';
                const hrFixed = document.createElement('hr');
                hrFixed.classList.add('horizontal-line');
                fixedTitle.append(hrFixed)

                const titleFix = document.createElement('div');
                titleFix.classList.add('block-title');
                titleFix.innerText = "Fixed parameters"
                fixedTitle.append(titleFix)

                variableTitle.innerText = '';
                const hrVar = document.createElement('hr');
                hrVar.classList.add('horizontal-line');
                variableTitle.append(hrVar)

                const titleVar = document.createElement('div');
                titleVar.classList.add('block-title');
                titleVar.innerText = "Search space"
                variableTitle.append(titleVar)

                if (container) container.innerHTML = '';  // Clear existing parameters
                if (containerFixed) containerFixed.innerHTML = '';
                if (containerVariable) containerVariable.innerHTML = '';
                if (containerFixedPulse) containerFixedPulse.innerHTML = '';
                if (containerVariablePulse) containerVariablePulse.innerHTML = '';

                if (globalData.multiple_sets?.value) { //Extend this so not only num_electrodes?
                    // TODO This would be a hard requirements and needs to be documented.
                    console.log("Data has multiple sets")
                    const row = document.createElement('div');
                    row.classList.add('parameter-row')
                    row.id = 'electrode-sets-row'

                    const label = document.createElement('div');
                    label.classList.add('parameter-label');
                    label.innerText = "Num. of electrodes"

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.id = 'param_num_electrodes';
                    input.value = globalData.num_electrodes.value;
                    input.min = globalData.num_electrodes.min_value;
                    input.max = globalData.num_electrodes.max_value;
                    input.onchange = updateParameters;

                    row.appendChild(label)
                    row.appendChild(input)

                    container.append(row)
                }
                await updateParameters()

            }
        }

        // Helper functions
        function createParameterContainer() {
            const container = document.createElement('div');
            container.classList.add('parameter-container');
            return container;
        }

        function createLabel(key, type, data) {
            const label = document.createElement('div');
            label.classList.add('parameter-label');
            if (type === 'boolean') {
                label.innerText = `${key} boolean`;
            } else if (type === 'cat' || type === 'cat-mult') {
                label.innerText = `${key} options`;
            } else {
                label.innerText = `${key} [${data.min_value}, ${data.max_value}]`;
            }
            return label;
        }

        function createSelectInput(keyOrId, options, index = null, isMultiple = true) {
            const select = document.createElement('select');
            select.multiple = isMultiple;
            // Determine ID based on input type
            if (index !== null) {
                const key = keyOrId;
                select.id = `param_${key}_${index}`;
            } else {
                select.id = keyOrId; // Direct ID for simpler cases
            }

            // Populate options
            options.forEach((optionText, i) => {
                const option = document.createElement('option');
                option.value = optionText;
                option.innerText = optionText;
                if (i === 0) option.selected = true; // Select first by default
                select.appendChild(option);
            });

            return select;
        }
        function createNumericInputRow(key, data, index=null) {
            const inputRow = createInputRow(key, false);
            const valueInput = document.createElement('input');
            valueInput.type = 'number';
            valueInput.id = index !== null ? `param_${key}_${index}` : `param_${key}`;
            if (data.value !== null) valueInput.value = data.value;
            if (data.min !== null) valueInput.min = data.min;
            if (data.max !== null) valueInput.max = data.max;

            inputRow.appendChild(valueInput);
            return inputRow;
        }

        function addFixedNumericMultipleInputs(container, key, data, columns, index = null) {
            const loopStart = index !== null ? index : 0;
            const loopEnd = index !== null ? index + 1 : columns;

            for (let i = loopStart; i < loopEnd; i++) {
                container.appendChild(createNumericInputRow(key, data, i));
            }
        }
        function addSingleNumericInput(container, key, data, index=null) {
            container.appendChild(createNumericInputRow(key, data, index));
        }

        function addCatMultInputs(container, key, data, columns, index = null) {
            const loopStart = index !== null ? index : 0;
            const loopEnd = index !== null ? index + 1 : columns;

            for (let i = loopStart; i < loopEnd; i++) {
                const inputRow = createSelectRow(key, data.possible_values, i );
                container.appendChild(inputRow);
            }
        }

        function addSingleCatInput(container, key, data, index=null) {
            container.appendChild(createSelectRow(key, data.possible_values, index));
        }

        function addArrayInputs(container, key, data, columns) {
            for (let i = 0; i < columns; i++) {
                const inputRow = document.createElement('div');
                inputRow.classList.add('input-row');

                const rowLabel = createRowLabel(i);
                inputRow.appendChild(rowLabel);

                data.dimensions.forEach((dim, dimIndex) => {
                    const dimLabel = document.createElement('div');
                    dimLabel.classList.add('dim-label');
                    dimLabel.innerText = `${dim}:`;

                    const valueInput = document.createElement('input');
                    valueInput.type = 'number';
                    valueInput.id = `param_${key}_${dim}_${i}`;
                    valueInput.value = data.value?.[dimIndex] || 0;
                    if (data.min_value && data.max_value) {
                        valueInput.min = data.min_value[dimIndex];
                        valueInput.max = data.max_value[dimIndex];
                    }
                    inputRow.appendChild(dimLabel);
                    inputRow.appendChild(valueInput);
                });

                container.appendChild(inputRow);
            }
        }

        function createInputRow(key, insertBoolean = false) {
            const inputRow = document.createElement('div');
            inputRow.classList.add('input-row');

            // Create label for the row, adjusted for index and column count
            const rowLabel = document.createElement('div');
            rowLabel.classList.add('row-ix');

            if (insertBoolean) {
                // Create a checkbox for boolean inputs
                rowLabel.innerText = "set (True)"
                const booleanInput = document.createElement('input');
                booleanInput.type = 'checkbox';
                booleanInput.id = `param_${key}`;
                inputRow.appendChild(rowLabel); // Add the label first
                inputRow.appendChild(booleanInput); // Add the checkbox input
            }

            inputRow.appendChild(rowLabel);

            return inputRow;
        }
        function createSelectRow(key, options, index=null) {
            const inputRow = document.createElement('div');
            inputRow.classList.add('input-row');

            const rowLabel = createRowLabel(index);
            const selectInput = document.createElement('select');
            selectInput.id = index !== null ? `param_${key}_${index}` : `param_${key}`;

            options.forEach((value) => {
                const option = document.createElement('option');
                option.value = value;
                option.innerText = value;
                selectInput.appendChild(option);
            });
            inputRow.appendChild(rowLabel);
            inputRow.appendChild(selectInput);
            return inputRow;
        }

        function createRowLabel(index) {
            const label = document.createElement('div');
            label.classList.add('row-ix');
            label.innerText = index === 1 ? '' : `e_${index + 1}`;
            return label;
        }

        // Helper for numeric multi-inputs (e.g., int-mult, float-mult)
        function addVariableNumericMultipleInputs(container, key, paramData, electrode_ix) {
            const inputRow = document.createElement('div');
            inputRow.classList.add('input-row');
            inputRow.appendChild(createNumericInput(key, paramData, electrode_ix, 'min'));
            inputRow.appendChild(createNumericInput(key, paramData, electrode_ix, 'max'));
            container.appendChild(inputRow);
        }
        // Helper for single numeric inputs (e.g., int, float)
        function addNumericInput(container, key, paramData, i=null) {
            const inputRow = document.createElement('div');
            inputRow.classList.add('input-row');
            inputRow.appendChild(createNumericInput(key, paramData, i, 'min'));
            inputRow.appendChild(createNumericInput(key, paramData, i, 'max'));
            container.appendChild(inputRow);
        }
        // Helper for categorical multi-inputs (e.g., cat-mult)
        function addCategoricalMultiInput(container, key, paramData, numColumns) {
            for (let i = 0; i < numColumns; i++) {
                const inputRow = createInputRow(`e_${i + 1}`);
                inputRow.appendChild(createSelectInput(key, paramData.possible_values, i));
                container.appendChild(inputRow);
            }
        }

        // Helper for single categorical inputs (e.g., cat)
        function addCategoricalInput(container, key, paramData) {
            const inputRow = createInputRow('Select categories');
            inputRow.appendChild(createSelectInput(key, paramData.possible_values));
            container.appendChild(inputRow);
        }

        // Helper for array inputs
        function addArrayInput(container, key, paramData, numColumns) {
            const dimensions = paramData.dimensions;
            for (let i = 0; i < numColumns; i++) {
                const inputRow = createInputRow(`e_${i + 1}`);
                dimensions.forEach((dim, dimIndex) => {
                    inputRow.appendChild(createDimensionLabel(dim));

                    inputRow.appendChild(createNumericInput(key, paramData, i, 'min', dimIndex));
                    inputRow.appendChild(createNumericInput(key, paramData, i, 'max', dimIndex));
                });
                container.appendChild(inputRow);
            }
        }

        // Helper for boolean inputs
        function addBooleanInput(container, key) {
            const inputRow = createInputRow(key, true);
            //inputRow.appendChild(inputRow);
            container.appendChild(inputRow);
        }

        // Create numeric inputs with min/max handling
        //key, paramData, i, 'min')
        function createNumericInput(keyOrId, paramData = null, index = null, bound = null, dimIndex = null, simpleValue = null, simpleMin = null, simpleMax = null) {
            const input = document.createElement('input');
            input.type = 'number';

            if (paramData) {
                // Use complex structure with key, index, bound, and optional dimIndex
                const key = keyOrId;
                input.id = dimIndex !== null
                    ? `param_${key}_${paramData.dimensions[dimIndex]}_${bound}_${index}`
                    : `param_${key}_${bound}${index !== null ? `_${index}` : ''}`;

                const valueKey = bound === 'min' ? 'min_value' : 'max_value';
                const boundValue = Array.isArray(paramData[valueKey])
                    ? paramData[valueKey][dimIndex]
                    : paramData[valueKey];

                input.value = boundValue || 0;
                input.min = paramData.min_value;
                input.max = paramData.max_value;
            } else {
                // Use simpler structure with id, value, min, and max
                input.id = keyOrId;
                input.value = simpleValue;
                input.min = simpleMin;
                input.max = simpleMax;
            }

            return input;
        }

        // Create dimension labels for array inputs
        function createDimensionLabel(dim) {
            const dimLabel = document.createElement('div');
            dimLabel.classList.add('dim-label');
            dimLabel.innerText = `${dim}:`;
            return dimLabel;
        }

        async function updateFixedParameters(keyList, selData, container_name, append=false, index=null){
            const container = document.getElementById(container_name);
            const numColumnsInput = document.getElementById('param_num_electrodes');
            const numColumnsValue = append === false
                ? (numColumnsInput ? numColumnsInput.value : 0)
                : null;

            if (!append) container.innerHTML = ''; // Clear existing parameters

            const inputActions = {
                'int-mult': addFixedNumericMultipleInputs,
                'float-mult': addFixedNumericMultipleInputs,
                'int': addSingleNumericInput,
                'float': addSingleNumericInput,
                'cat-mult': addCatMultInputs,
                'cat': addSingleCatInput,
                'array': addArrayInputs,
                'boolean': addBooleanInput
            };

            keyList.forEach(key => {
                const type = selData[key]['type'];
                const parameterContainer = createParameterContainer();
                const label = createLabel(key, type, selData[key]);
                const inputsContainer = document.createElement('div');
                inputsContainer.classList.add('inputs-container');

                const action = inputActions[type];
                if (action) {
                    action(inputsContainer, key, selData[key], numColumnsValue);
                } else {
                    console.warn(`Unknown type: ${type}`);
                }

                parameterContainer.appendChild(label);
                parameterContainer.appendChild(inputsContainer);
                container.appendChild(parameterContainer);
            });
        }
        async function updateVariableParameters(keyList, selData, container_name, append=false){
            const container = document.getElementById(container_name);
            const numColumnsInput = document.getElementById('param_num_electrodes');

            const numColumnsValue = append === false
                ? (numColumnsInput ? numColumnsInput.value : 0)
                : null;

            if (!append) container.innerHTML = ''; // Clear existing parameters

            const inputActions = {
                'int-mult': addVariableNumericMultipleInputs,
                'float-mult': addVariableNumericMultipleInputs,
                'int': addNumericInput,
                'float': addNumericInput,
                'cat-mult': addCategoricalMultiInput,
                'cat': addCategoricalInput,
                'array': addArrayInput,
                'boolean': addBooleanInput
            };

            const fixedAction = {
                'int-mult': addFixedNumericMultipleInputs,
                'float-mult': addFixedNumericMultipleInputs,
                'int': addSingleNumericInput,
                'float': addSingleNumericInput,
                'cat-mult': addCatMultInputs,
                'cat': addSingleCatInput,
                'array': addArrayInputs,
                'boolean': addBooleanInput
            };

            keyList.forEach(key => {
                const type = selData[key]['type'];
                const paramData = selData[key];
                const parameterContainer = createParameterContainer(key);
                const label = createLabel(key, type, selData[key]);
                const inputsContainer = document.createElement('div');
                inputsContainer.classList.add('inputs-container');

                // Add checkbox for min-max toggle
                const toggleContainer = document.createElement('div');
                const toggleLabel = document.createElement('label');
                toggleLabel.textContent = "Fix value";
                toggleLabel.classList.add('white-text');

                const toggleCheckbox = document.createElement('input');
                toggleCheckbox.type = 'checkbox';

                toggleCheckbox.id = `toggle_${key}_${numColumnsValue}`;

                toggleContainer.appendChild(toggleLabel);
                toggleContainer.appendChild(toggleCheckbox);

                // Add event listener to handle toggle
                toggleCheckbox.addEventListener('change', (event) => {
                    const isFixed = event.target.checked;
                    inputsContainer.innerHTML = ''; // Clear existing inputs
                    const action = isFixed ? fixedAction[type] : inputActions[type];

                    if (action) {
                        action(inputsContainer, key, paramData, numColumnsValue);
                    } else {
                        console.warn(`Unknown type: ${type}`);
                    }
                });

                const initialAction = toggleCheckbox.checked ? fixedAction[type] : inputActions[type];
                console.log("***", key, numColumnsValue)
                if (initialAction) {
                    initialAction(inputsContainer, key, paramData, numColumnsValue);
                } else {
                    console.warn(`Unknown type: ${type}`);
                }

                parameterContainer.appendChild(label);
                parameterContainer.appendChild(toggleContainer); // Add the toggle checkbox
                parameterContainer.appendChild(inputsContainer);
                container.appendChild(parameterContainer);
            });
        }
        // Function to draw the plot
        function drawPlot() {
            const num_el_container = document.getElementById('param_num_electrodes')
            if (!num_el_container){ //There are no electrodes in the problem, this plot is not needed.
                return
            }
            const num_el = parseInt(num_el_container.value, 10)
            const centerX = 110
            const canvas = document.getElementById('plotCanvas')

            let height
            if (globalData['name'].startsWith("axonsim")){
                height = parseFloat(document.getElementById('param_dia').value)
            }
            else if (globalData['name'].startsWith("cajal")){
                height = parseFloat(document.getElementById('param_axon_diameter').value)
            }
            else{
                console.error("The input is not valid")
            }

            const dims = globalData['e_pos']['dimensions']
            const ctx = canvas.getContext('2d');
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the x and y axes
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2); // X axis
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.moveTo(canvas.width / 2, 0); // Y axis
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();

            // Draw the rectangle
            const rectWidth = 250; // Adjust rectangle width
            const rectX = centerX - rectWidth / 2;
            const rectY = (canvas.height / 2) - (height / 2); // Centered vertically

            ctx.fillStyle = 'rgba(100, 150, 200, 0.5)'; // Rectangle color
            ctx.fillRect(rectX, rectY, rectWidth, height);
            ctx.fillStyle = 'red'; // Electrode marker color

            // Plot electrode positions
            for (let n=0; n<=num_el-1; n++){
                let pos = []
                for (let dim in dims) {
                    const el = document.getElementById(`param_e_pos_${dims[dim]}_${n}`);
                    pos.push(parseFloat(el.value))
                }
                const markerX = 10*pos[0] + (canvas.width / 2); // Center the electrodes
                const markerY = -10*pos[1] + (canvas.height/2); // Visually speaking, Positive values are above from the origin
                ctx.fillText('x', markerX, markerY); // Place above rectangle
            }

        }
        function draw3DPlot() {
            const num_el_container = document.getElementById('param_num_electrodes')
            if (!num_el_container) { // There are no electrodes in the problem, this plot is not needed.
                return
            }
            const num_el = parseInt(num_el_container.value, 10)
            const centerX = 110
            const canvas = document.getElementById('plotCanvas')
            const height = parseFloat(document.getElementById('param_axon_diameter').value)
            const dims = globalData['e_pos']['dimensions']

            // Create the scene and camera
            const scene = new THREE.Scene()
            const camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000)
            const renderer = new THREE.WebGLRenderer({ canvas: canvas })
            renderer.setSize(canvas.width, canvas.height)

            // Set camera position
            camera.position.z = 500

            // Add axes for reference
            const axesHelper = new THREE.AxesHelper(100)
            scene.add(axesHelper)

            // Draw the rectangle as a 3D box
            const geometry = new THREE.BoxGeometry(250, height, 10) // Width, height, depth
            const material = new THREE.MeshBasicMaterial({ color: 0x6496c8, transparent: true, opacity: 0.5 })
            const rect = new THREE.Mesh(geometry, material)
            scene.add(rect)

            // Center the rectangle
            rect.position.set(centerX, 0, 0) // Adjust rectangle position

            // Create a material for the electrode markers
            const electrodeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 })

            // Plot electrode positions
            for (let n = 0; n <= num_el - 1; n++) {
                let pos = []
                for (let dim in dims) {
                    const el = document.getElementById(`param_e_pos_${dims[dim]}_${n}`);
                    pos.push(parseFloat(el.value))
                }
                const electrodeGeometry = new THREE.SphereGeometry(5, 32, 32) // Small sphere for electrodes
                const electrode = new THREE.Mesh(electrodeGeometry, electrodeMaterial)

                // Set electrode position (scaled to fit canvas)
                electrode.position.set(10 * pos[0] + centerX, -10 * pos[1], 10 * pos[2])

                scene.add(electrode)
            }

            // Rendering loop
            function animate() {
                requestAnimationFrame(animate)
                renderer.render(scene, camera)
            }

            animate() // Start animation loop
        }
        function renderJSON(container, data) {
            for (const [key, value] of Object.entries(data)) {
                const keyElement = document.createElement('div');
                keyElement.className = 'json-key';
                keyElement.textContent = `${key}: `;

                const valueElement = document.createElement('span');
                valueElement.className = 'json-value';
                renderJSON(valueElement, value); // Recursive call
                keyElement.appendChild(valueElement);
                div.appendChild(keyElement);

            }
        }
        function updateJSONDisplay() {
            const parameters = collectInputs('sidebar-left');
            const structuredData = restructureParameters(parameters);
            const jsonDisplay = document.getElementById('jsonDisplay');
            jsonDisplay.innerHTML = ''; // Clear previous content
            renderJSON(jsonDisplay, structuredData);
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', fetchExperiments)
        const jsonInputs = document.querySelectorAll('#sidebar-left input');
        jsonInputs.forEach(input => {
            input.addEventListener('input', updateJSONDisplay);
        });
    </script>

    <script>
        // Function to create and append iFrames
        async function createIframes() {
            await removeIframes()
            const iframeContainer = document.getElementById('iframeContainer');

            // Example list of iFrame configurations
            const iframeConfigs = [
                { id: 'mainPlot', src: 'http://localhost:{{ port }}/plot?type=plotly' },
                { id: 'scatterPlot', src: 'http://localhost:{{ port }}/plot?type=contour' }
            ];

            iframeConfigs.forEach(config => {
                if (!document.getElementById(config.id)) {
                    const iframe = document.createElement('iframe');
                    iframe.id = config.id;
                    iframe.src = config.src;
                    iframe.style.width = '100%';
                    //iframe.style.height = '500px';
                    iframeContainer.appendChild(iframe);
                }
            });
        }

        // Function to remove (or hide) iFrames
        function removeIframes() {
            const iframeContainer = document.getElementById('iframeContainer');
            const existingIframes = iframeContainer.querySelectorAll('iframe');
            existingIframes.forEach(iframe => {
                iframe.remove(); // Alternatively, use iframe.style.display = 'none'; to hide instead of removing
            });
        }
        // Attach event listeners to buttons
        // document.getElementById('startButton').addEventListener('click', createIframes);
        // document.getElementById('stopButton').addEventListener('click', removeIframes);
  </script>

</head>
<body>

    <!-- Sidebar -->
    <div class="sidebar" id="sidebar-left">
        <div class="header">
            <h2>Configuration</h2>
        </div>
        <div class="sidebar-frame" id="toggle-btn">
            <button class="toggle-btn" onclick="toggleSidebar()">â˜°</button>
        </div>

        <!-- Toggle button for the sidebar -->
        <!-- Dropdown for selecting experiments -->
        <div class="sidebar-frame" id="exp-selector">
            <select id="experiment" class="styled-select" onchange="experimentChange()">
            <option value="">Select Experiment...</option>
            <!-- Options generated dynamically -->
            </select>
        </div>

        <div id="parameters-header-fixed"></div>
        <div id="parameters-container-num"></div>
        <div id="parameters-container-fixed"></div>
        <div id="parameters-container-fixed-pulse"></div>

        <div id="parameters-header-rest"></div>
        <div id="parameters-container-rest"></div>
        <div id="parameters-container-variable-pulse"></div>

        <div class="experiments-box">

        <button id="startExpermient" onclick="startExperiment()">Start Experiment</button>
        <button id="checkStatus" onclick="checkStatus()">Check Status</button>
        <button id="stopExpermient" onclick="stopExperiment()">Stop Experiment</button>

        </div>
        <canvas id="plotCanvas" width="150" height="150"></canvas>

        <div id="json-view" ></div>

    </div>

    <!-- Main content -->
    <div id="spinner" class="spinner"></div>

    <div class="content" id="iframeContainer"></div>
    <div class="sidebar-right" id="sidebar-model">
        <div class="header">
            <h2>Problem config</h2>
        </div>
        <div class="sidebar-frame" id="toggle-btn-right">
            <button class="toggle-btn" onclick="toggleSidebarRight()">â˜°</button>
        </div>
    </div>

</body>
</html>