<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Data Plots</title>
    <style>
        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #333;
        }

        h1 {
            text-align: center;
            color: #c02a4e;
        }

        /* Main container for content */
        .content {
            margin-left: 250px; /* Width of the sidebar */
            padding: 20px;
            transition: margin-left 0.3s ease;
        }

        /* Sidebar styling */
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 250px;
            height: 100%;
            background-color: #0e0e0e;
            padding: 15px;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
            transition: width 0.3s ease;
        }
        .sidebar-right {
            position: fixed;
            top: 0;
            right: 0; /* Changed from left: 0 to right: 0 */
            width: 250px;
            height: 100%;
            background-color: #0e0e0e;
            padding: 15px;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.2); /* Adjusted the shadow to appear on the left */
            transition: width 0.3s ease;
        }

        .header {
            display: flex;
            align-items: center;
        }

        .sidebar h2 {
            color: #6b6b6b;
            margin-top: 0;
        }
        .sidebar experiment-box{
            display: block;
            width: 100%;
            margin-bottom: 10px;
            padding: 10px;
        }

        .sidebar button {
            display: block;
            width: 100%;
            margin-bottom: 10px;
            padding: 10px;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }

        .sidebar button:hover {
            background-color: #e0e0e0; /* Button hover effect */
        }

        /* Style for the select dropdown */
        .styled-select {
            background-color:  #333; /* Black background */
            color: white; /* White text */
            border: none;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            width: 100%; /* Full width */
            text-align: left; /* Align text to left */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s ease;
            appearance: none; /* Remove default select arrow for some browsers */
            -webkit-appearance: none; /* Safari/Chrome */
            -moz-appearance: none; /* Firefox */
        }

        /* Optional: Adding an arrow indicator to match the dropdown button feel */
        .styled-select::after {
            content: 'â–¼';
            position: absolute;
            right: 10px;
            pointer-events: none;
        }

        /* Hover effect to match button hover */
        .styled-select:hover {
            background-color: #333; /* Darker background on hover */
        }
        /* Show the dropdown content when the button is clicked */
        .show {
            display: block;
        }

        /* Toggle button for opening/closing sidebar */
        .sidebar-frame{
            /*margin-bottom: 10px;*/
            padding: 10px;
            border-radius: 5px;
        }
        .toggle-btn {
            position: absolute;
            display: block;
            top: 50px;
            left: 20px;
            font-size: 18px;
            background-color: #c02a4e;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        /* When the sidebar is hidden */
        .sidebar-closed {
            width: 0;
            overflow: hidden;
        }
        .content-expanded {
            margin-left: 30px;
        }
        iframe {
            display: block;
            margin: 20px auto;
            border: none;
            width: 100%;
            height: 400px;
        }
        .parameter-container{
            display:flex;
            align-items:center;
            margin-bottom: 10px;
            width: 100%;
        }
        .block-title{
            margin-bottom: 5px;
            font-weight: bold;
            font-size: large;
            color: white;
            text-overflow: ellipsis
        }
        .parameter-label{
            text-align: left;
            margin-right: 8px;
            color: white;
            /*white-space: nowrap;*/
            /*width: 100px;*/
            text-overflow: ellipsis
        }
        .inputs-container {
            display: flex;               /* Use flexbox for the inputs */
            flex-direction: column;      /* Stack input rows vertically */
        }
        .inputs-container input{
            width: 50px;
            margin-right: 8px
        }
        .input-row{
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .row-ix{
            width: 40px;
            /*text-align: left;*/
            font-weight: normal;
            color:white;
            align-content: center;
        }
        .dim-label{
            color:white
        }
        .parameter-row{
            display: flex;
            /*flex-wrap: wrap;*/
            gap: 10px;
            max-width: 100%;
        }
        .box {
            width: 100%;
            height: 150px;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
        }
        /* Loading spinner */
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ff3737;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            display: none;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .horizontal-line {
            border: none; /* Remove default border */
            height: 2px; /* Line thickness */
            background-color: #ccc; /* Line color */
            margin-bottom: 8px; /* Space below the line */
        }
        .white-text {
            color: white;
        }

    </style>
    <script>
        let globalData
        let optimizableFeatures
        let fixedFeatures

        //let sortedKeys
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const content = document.querySelector('.content');
            sidebar.classList.toggle('sidebar-closed');
            content.classList.toggle('content-expanded');
        }
        function toggleSidebarRight() {
            const sidebar = document.querySelector('.sidebar-right');
            const content = document.querySelector('.content');
            sidebar.classList.toggle('sidebar-closed');
            content.classList.toggle('content-expanded');
        }
        function showSpinner(show) {
            document.getElementById('spinner').style.display = show ? 'block' : 'none';
        }

        function cleanFinalParameters(params) {
            Object.keys(params).forEach(key => {
                const paramData = params[key];

                // Check if it's an object with min_value and max_value keys
                if (paramData.min_value && Array.isArray(paramData.min_value)) {
                    paramData.min_value = paramData.min_value.filter(val => val !== null);
                }

                if (paramData.max_value && Array.isArray(paramData.max_value)) {
                    paramData.max_value = paramData.max_value.filter(val => val !== null);
                }

                // If it's a single value array, handle it similarly
                if (paramData.value && Array.isArray(paramData.value)) {
                    paramData.value = paramData.value.filter(val => val !== null);
                }
            });

            return params;
        }
        function restructureParameters(data){
            const finalParameters = {};
            const sortedElectrodeKeys = {};

            console.log("Collected data");
            console.log(data);

            // Loop through the data to organize based on electrode number
            Object.entries(data).forEach(([key, value]) => {
                // Extract electrode number from the key
                const matchNum = key.match(/_(\d+)$/);
                const electrodeIndex = matchNum ? parseInt(matchNum[1], 10) : null;
                const matchMinMax = key.match(/_(min|max)$/);

                if (electrodeIndex !== null) {
                    // Base key for globalData lookup
                    const baseKey = key.replace(/_(\d+)$/, "");

                    if (!sortedElectrodeKeys[baseKey]) {
                        sortedElectrodeKeys[baseKey] = [];
                    }
                    sortedElectrodeKeys[baseKey][electrodeIndex] = value; // Store value at the corresponding index
                } else {
                    // Handle non-electrode specific keys
                    const tempKey = key.replace("param_", "");

                    if (matchMinMax == null) {
                        finalParameters[tempKey] = {"value": value}; // Directly assign the value
                    }
                    else{
                        const baseKey = tempKey.replace(/_(min|max)$/, "");
                        if (!finalParameters[baseKey]) {
                            finalParameters[baseKey] = {
                                min_value: [],
                                max_value: []
                            }
                        }
                        console.log(baseKey, matchMinMax[0], matchMinMax[1])
                        if(matchMinMax[0] == '_min'){
                            finalParameters[baseKey]['min_value'] = [value]
                        }else if(matchMinMax[0] =='_max'){
                            finalParameters[baseKey]['max_value'] = [value]
                        }else{
                            throw new Error("Not a valid limit (?)");
                        }
                    }
                }
            });

            Object.entries(sortedElectrodeKeys).forEach(([key, value]) => {
                // Remove the 'param_' prefix and check for min/max in the name
                let baseKey = key.replace("param_", "");
                let isRange = baseKey.includes('_min') || baseKey.includes('_max');

                // If it's a range (min or max), we extract the base key without the _min/_max suffix
                if (isRange) {
                    baseKey = baseKey.replace(/_(min|max)$/, "");
                }

                // Now check if baseKey exists in globalData
                let actualKey = baseKey;
                let interleaved = false;
                if (!globalData.hasOwnProperty(baseKey)) {
                    // If not in globalData, remove the last underscore and dimension part
                    actualKey = baseKey.replace(/_[^_]+$/, "");
                    interleaved = true;
                }
                if (actualKey in finalParameters){ //key already added
                    return;
                }

                const globalInfo = globalData[actualKey];  // Get global info for this key

                // If we have a range (min/max) case, store values as min and max
                if (isRange) {
                    // Initialize the range structure if it doesn't exist
                    if (!finalParameters[actualKey]) {
                        finalParameters[actualKey] = {
                            min_value: [],
                            max_value: []
                        };

                    }
                    if (interleaved) {
                        const interleavedValuesMin = [];
                        const interleavedValuesMax = [];

                        for (let i = 0; i < value.length; i++) {
                            globalInfo.dimensions.forEach((dim, dim_ix) => {
                                const minKey = `param_${actualKey}_${dim}_min`;
                                const maxKey = `param_${actualKey}_${dim}_max`;
                                if(sortedElectrodeKeys[minKey]){
                                    interleavedValuesMin.push(sortedElectrodeKeys[minKey][i])
                                }
                                if(sortedElectrodeKeys[maxKey]){
                                    interleavedValuesMax.push(sortedElectrodeKeys[maxKey][i]);
                                }
                            });
                        }

                        finalParameters[actualKey] = {'min_value':interleavedValuesMin,
                                                      'max_value':interleavedValuesMax }

                    }
                    else{
                        const minKey = `param_${actualKey}_min`;
                        const maxKey = `param_${actualKey}_max`;

                        finalParameters[actualKey] = {
                            "min_value": sortedElectrodeKeys[minKey],
                            "max_value": sortedElectrodeKeys[maxKey]
                        }
                    }
                } else {
                    // It's a simple value assignment
                    if (!finalParameters[actualKey]) {
                        finalParameters[actualKey] = {
                            value: [],
                        };
                    }
                    if (interleaved){
                        const dimensions = globalInfo.dimensions;
                        const interleavedValues = [];
                        // Interleave the values across the dimensions
                        for (let i = 0; i < value.length; i++) {
                            dimensions.forEach((dim) => {
                                const specificKey = `param_${actualKey}_${dim}`;
                                interleavedValues.push(sortedElectrodeKeys[specificKey][i]);
                            });
                        }
                        // Assign the interleaved values
                        finalParameters[actualKey] = {
                            "value": interleavedValues
                        };
                    } else {
                        finalParameters[actualKey] = {
                            "value": value
                        }
                    }
                }
            });

            const cleanedParameters = cleanFinalParameters(finalParameters);
            return cleanedParameters
        }

        function collectInputs(elementId){
            const sidebarFrame = document.getElementById(elementId);
            const inputs = sidebarFrame.querySelectorAll('input');

            // Create an object to store the parameter values
            const parameters = {};
            inputs.forEach(input => {
                if (input.type === 'checkbox') {
                    // For checkboxes, store true or false depending on whether it's checked
                    parameters[input.id] = input.checked;
                } else {
                    // For other inputs, store the value
                    parameters[input.id] = input.value;
                }
            });

            const selects = sidebarFrame.querySelectorAll('select');
            selects.forEach(select =>{
                parameters[select.id] = select.options[select.selectedIndex].value;  // Get selected option value
            });

            return parameters

        }

        async function startExperiment() {
            showSpinner(true);

            const experimentSelector = document.getElementById('experiment');
            const selectedExperiment = experimentSelector.value;
            // Collect all inputs from the "sidebar-frame" div
            let parameters = collectInputs('sidebar-left')
            parameters = restructureParameters(parameters)

            console.log("Package sent")
            console.log(parameters)
            const bodyData = {
                problem: selectedExperiment,  // Add the selected experiment
                parameters: parameters            // Add the collected input
                };

            try {
                const response = await fetch('/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(bodyData),
                });
                const data = await response.json();
                console.log(data);

            } catch(error) {
                console.error('Error starting the experiment:', error);
            } finally {
                    // Hide the loading spinner
                    showSpinner(false);
            }
        }

        async function checkStatus() {
            const response = await fetch('/status');
            const data = await response.json();
            console.log(data);
        }

        async function stopExperiment() {
            showSpinner(true);
            const response = await fetch('/stop', { method: 'POST' });
            const data = await response.json();
            console.log(data);
            showSpinner(false);
        }


        // Function to display the selected experiment
        async function fetchExperiments() {
            try {
                const response = await fetch('/experiments');  // API route that returns JSON
                const experiments = await response.json();  // Ensure the response is parsed as JSON

                const experimentSelector = document.getElementById('experiment');

                // Clear existing options (if any)
                experimentSelector.innerHTML = '<option value="">Select Experiment</option>'; // Reset to default option

                // Populate the select element with the fetched experiments
                experiments.forEach(exp => {
                    const option = document.createElement('option');
                    option.value = exp; // Set the value for the option
                    option.innerText = exp; // Display the experiment name
                    experimentSelector.appendChild(option); // Append the option to the select
                });
            } catch (error) {
                console.error("Error fetching data:", error);
            }
        }
        function sortFeatures(features, dataDic) {
            return features.sort((a, b) => {
                if (dataDic[a].type < dataDic[b].type) return -1;
                if (dataDic[a].type > dataDic[b].type) return 1;
                if (a < b) return -1;
                if (a > b) return 1;

                return 0; // if they are equal
            });
        }
        async function updatePulseParameters(){
            const pulseTypes = Array.from(document.querySelectorAll('[id^="param_fun_type_"]')).reduce((acc, input) => {
                const match = input.id.match(/_(\d+)$/); // Extract the number at the end of the ID
                if (match) {
                    const number = match[1]; // Get the matched number
                    acc[number] = input.value; // Assign the input value to the corresponding number
                }
                return acc; // Return the accumulator for the next iteration
            }, {});
            if (Object.keys(pulseTypes).length == 0){
                return;
            }

            let configs = [];
            await Promise.all(Object.values(pulseTypes).map(async pt => { // Use Object.values to iterate
                const response = await fetch('/get_fun_parameters', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({function: pt}) // Pass the experiment as JSON in the body
                });
                if (!response.ok) {
                    console.error("Error fetching parameters:", response.statusText);
                    return;
                }
                let this_config = await response.json()
                configs.push(this_config)
                }));

            for (let i = 0; i < configs.length; i++) {
                const pulseConfig = configs[i];

                if (!pulseConfig || typeof pulseConfig !== 'object') {
                    console.warn("Invalid pulse configuration:", pulseConfig);
                    continue;
                }
                // Update globalData with pulseConfig data
                Object.keys(pulseConfig).forEach(key => {
                    if (!globalData[key]) {  // Add if it doesn't already exist
                        globalData[key] = pulseConfig[key];
                    } else {
                        // Merge/overwrite data if key already exists
                        globalData[key] = { ...globalData[key], ...pulseConfig[key] };
                    }
                });

                let optPulseFeatures = Object.keys(pulseConfig).filter(key => pulseConfig[key].optimizable ===true)
                let fixPulseFeatures = Object.keys(pulseConfig).filter(key => pulseConfig[key].user_fixed ===true)
                optPulseFeatures = sortFeatures(optPulseFeatures, pulseConfig);
                fixPulseFeatures = sortFeatures(fixPulseFeatures, pulseConfig);

                await updateFixedParameters(fixPulseFeatures, pulseConfig, 'parameters-container-fixed-pulse', i)
                await updateVariableParameters(optPulseFeatures, pulseConfig, 'parameters-container-variable-pulse', i)

            }

            Object.keys(pulseTypes).forEach(number => {
                const input = document.getElementById(`param_fun_type_${number}`);
                input.onchange = () => updatePulseParameters();  // Call the function on change
            });

        }
        async function updateParameters(){
            await updateFixedParameters(fixedFeatures, globalData, 'parameters-container-fixed')
            await updateVariableParameters(optimizableFeatures, globalData , 'parameters-container-rest')
            await updatePulseParameters()

        }

        async function updateElectrodeListeners(){
            const e_pos_inputs = document.querySelectorAll('[id^="param_e_pos"]');
            e_pos_inputs.forEach(input => {
                input.addEventListener('change', drawPlot);
            });
            const diameterInput = document.getElementById('param_dia');
            diameterInput.addEventListener('change', drawPlot);
            await drawPlot()
        }

        async function addPlotListeners(){
            const experimentSelect = document.getElementById('experiment');
            experimentSelect.addEventListener('change', addPlotListeners);

            const num_electrodes = document.getElementById('num_electrodes');
            if (num_electrodes){
                num_electrodes.addEventListener('change', updateElectrodeListeners);
                await updateElectrodeListeners()
            }

        }
        async function experimentChange(){
            await loadParameters()
            if (globalData.hasOwnProperty('num_electrodes')) {
                await addPlotListeners();
                drawPlot();
            } else {
                // Clear the canvas if no electrodes are present
                const canvas = document.getElementById('plotCanvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
                console.log("No electrodes to plot.");
            }
        }
        async function loadParameters() {
            const selectedExperiment = document.getElementById('experiment').value;

            if (selectedExperiment===""){
                globalData = false
                const container = document.getElementById('parameters-container-num');
                const fixedTitle = document.getElementById('parameters-header-fixed');
                const variableTitle = document.getElementById('parameters-header-rest');
                const containerFixed = document.getElementById('parameters-container-fixed');
                const containerVariable = document.getElementById('parameters-container-rest');
                const containerFixedPulse = document.getElementById('parameters-container-fixed-pulse');
                const containerVariablePulse = document.getElementById('parameters-container-variable-pulse');


                container.innerHTML = '';  // Clear existing parameters
                fixedTitle.innerHTML = '';  // Clear existing parameters
                variableTitle.innerHTML = '';  // Clear existing parameters
                containerFixed.innerHTML = '';  // Clear existing parameters
                containerVariable.innerHTML = '';  // Clear existing parameters
                containerFixedPulse.innerHTML = ''; //Clear existing parameters
                containerVariablePulse.innerHTML = ''; //Clear existing parameters

            } else{
                const response = await fetch('/get_parameters', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({experiment: selectedExperiment}) // Pass the experiment as JSON in the body
                });

                if (!response.ok) {
                    console.error("Error fetching parameters:", response.statusText);
                    return;
                }

                globalData = await response.json();

                console.log("Received load")
                console.log(globalData)

                optimizableFeatures = Object.keys(globalData).filter(key => globalData[key].optimizable ===true)
                fixedFeatures = Object.keys(globalData).filter(key => globalData[key].user_fixed ===true)
                optimizableFeatures = sortFeatures(optimizableFeatures, globalData);
                fixedFeatures = sortFeatures(fixedFeatures, globalData);

                const container = document.getElementById('parameters-container-num');
                const containerFixed = document.getElementById('parameters-container-fixed');
                const containerVariable = document.getElementById('parameters-container-rest');
                const containerFixedPulse = document.getElementById('parameters-container-fixed-pulse');
                const containerVariablePulse = document.getElementById('parameters-container-variable-pulse');

                const fixedTitle = document.getElementById('parameters-header-fixed');
                const variableTitle = document.getElementById('parameters-header-rest');

                fixedTitle.innerText = '';
                const hrFixed = document.createElement('hr');
                hrFixed.classList.add('horizontal-line'); // Optional: Add a class for styling
                fixedTitle.append(hrFixed)

                const titleFix = document.createElement('div');
                titleFix.classList.add('block-title');
                titleFix.innerText = "Fixed parameters"
                fixedTitle.append(titleFix)

                variableTitle.innerText = '';
                const hrVar = document.createElement('hr');
                hrVar.classList.add('horizontal-line'); // Optional: Add a class for styling
                variableTitle.append(hrVar)

                const titleVar = document.createElement('div');
                titleVar.classList.add('block-title');
                titleVar.innerText = "Search space"
                variableTitle.append(titleVar)

                if (container) container.innerHTML = '';  // Clear existing parameters
                if (containerFixed) containerFixed.innerHTML = '';
                if (containerVariable) containerVariable.innerHTML = '';
                if (containerFixedPulse) containerFixedPulse.innerHTML = '';
                if (containerVariablePulse) containerVariablePulse.innerHTML = '';

                if (globalData.multiple_sets) { //Extend this so not only num_electrodes?
                    // TODO This would be a hard requirements and needs to be documented.
                    console.log("Data has multiple sets")
                    const row = document.createElement('div');
                    row.classList.add('parameter-row')
                    row.id = 'electrode-sets-row'

                    const label = document.createElement('div');
                    label.classList.add('parameter-label');
                    label.innerText = "Num. of electrodes"

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.id = 'num_electrodes';
                    input.value = globalData.num_electrodes.value;
                    input.min = globalData.num_electrodes.min_value;
                    input.max = globalData.num_electrodes.max_value;
                    input.onchange = updateParameters;

                    row.appendChild(label)
                    row.appendChild(input)

                    container.append(row)
                }
                await updateParameters()

            }
        }
        async function handleFunTypeChange(selectedFunType){
            const divToUpdateFixed = document.getElementById('parameters-container-fixed');
            const divToUpdateVariable = document.getElementById('parameters-container-rest');  // div to modify keys

            // if (globalData['fun_type'] && Array.isArray(globalData['fun_type'].value)) {
            //     const funTypes = globalData['fun_type'].value;
            //     for (let i = 0; i < funTypes.length; i++) {
            //         const funTypeValue = funTypes[i];
            //         const response = await fetch(`/check_fun_type`, {
            //             method: 'POST',
            //             headers: { 'Content-Type': 'application/json' },
            //             body: JSON.stringify({ fun_type: funTypeValue })
            //         })
            //         const reponseData = await response.json()
            //     }
            // }
        }
        // Helper functions
        function createParameterContainer() {
            const container = document.createElement('div');
            container.classList.add('parameter-container');
            return container;
        }

        function createLabel(key, type, data) {
            const label = document.createElement('div');
            label.classList.add('parameter-label');

            if (type === 'boolean') {
                label.innerText = `${key} boolean`;
            } else if (type === 'cat' || type === 'cat-mult') {
                label.innerText = `${key} options`;
            } else {
                label.innerText = `${key} [${data.min_value}, ${data.max_value}]`;
            }
            return label;
        }

        function createSelectInput(keyOrId, options, index = null, isMultiple = true) {
            const select = document.createElement('select');
            select.multiple = isMultiple;

            // Determine ID based on input type
            if (index !== null) {
                const key = keyOrId;
                select.id = `param_${key}_${index}`;
            } else {
                select.id = keyOrId; // Direct ID for simpler cases
            }

            // Populate options
            options.forEach((optionText, i) => {
                const option = document.createElement('option');
                option.value = optionText;
                option.innerText = optionText;
                if (i === 0) option.selected = true; // Select first by default
                select.appendChild(option);
            });

            return select;
        }
        function addNumericMultInputs(container, key, data, columns) {
            for (let i = 0; i < columns; i++) {
                const inputRow = createInputRow(key, i, data.value, data.min_value, data.max_value, columns);
                container.appendChild(inputRow);
            }
        }

        function addSingleNumericInput(container, key, data) {
            const inputRow = createInputRow(key, null, data.value, data.min_value, data.max_value, 1);
            container.appendChild(inputRow);
        }

        function addCatMultInputs(container, key, data, columns) {
            for (let i = 0; i < columns; i++) {
                const inputRow = createSelectRow(key, i, data.possible_values, columns);
                container.appendChild(inputRow);
            }
        }

        function addSingleCatInput(container, key, data) {
            const inputRow = createSelectRow(key, null, data.possible_values, 1);
            container.appendChild(inputRow);
        }

        function addArrayInputs(container, key, data, columns) {
            for (let i = 0; i < columns; i++) {
                const inputRow = document.createElement('div');
                inputRow.classList.add('input-row');

                const rowLabel = createRowLabel(i, columns);
                inputRow.appendChild(rowLabel);

                data.dimensions.forEach((dim, dimIndex) => {
                    const dimLabel = document.createElement('div');
                    dimLabel.classList.add('dim-label');
                    dimLabel.innerText = `${dim}:`;

                    const valueInput = document.createElement('input');
                    valueInput.type = 'number';
                    valueInput.id = `param_${key}_${dim}_${i}`;
                    valueInput.value = data.value?.[dimIndex] || 0;
                    if (data.min_value && data.max_value) {
                        valueInput.min = data.min_value[dimIndex];
                        valueInput.max = data.max_value[dimIndex];
                    }

                    inputRow.appendChild(dimLabel);
                    inputRow.appendChild(valueInput);
                });

                container.appendChild(inputRow);
            }
        }

        function createInputRow(key, index = null, value = null, min = null, max = null, columns = 1, isBoolean = false) {
            const inputRow = document.createElement('div');
            inputRow.classList.add('input-row');

            // Create label for the row, adjusted for index and column count
            const rowLabel = document.createElement('div');
            rowLabel.classList.add('row-ix');

            if (isBoolean) {
                // Create a checkbox for boolean inputs
                rowLabel.innerText = "set (True)"
                const booleanInput = document.createElement('input');
                booleanInput.type = 'checkbox';
                booleanInput.id = `param_${key}`;
                inputRow.appendChild(rowLabel); // Add the label first
                inputRow.appendChild(booleanInput); // Add the checkbox input
            } else {
                rowLabel.innerText = columns > 1 && index !== null ? `e_${index + 1}` : (index === null ? 'value' : `e_${index}`);

                // Create numeric input for other types
                const valueInput = document.createElement('input');
                valueInput.type = 'number';
                valueInput.id = index !== null ? `param_${key}_${index}` : `param_${key}`;
                if (value !== null) valueInput.value = value;
                if (min !== null) valueInput.min = min;
                if (max !== null) valueInput.max = max;

                // Append the label and input to the row container
                inputRow.appendChild(rowLabel);
                inputRow.appendChild(valueInput);
            }

            return inputRow;
        }
        function createSelectRow(key, index, options, columns) {
            const inputRow = document.createElement('div');
            inputRow.classList.add('input-row');

            const rowLabel = createRowLabel(index, columns);
            const selectInput = document.createElement('select');
            selectInput.id = index !== null ? `param_${key}_${index}` : `param_${key}`;

            options.forEach((value) => {
                const option = document.createElement('option');
                option.value = value;
                option.innerText = value;
                selectInput.appendChild(option);
            });

            inputRow.appendChild(rowLabel);
            inputRow.appendChild(selectInput);
            return inputRow;
        }

        function createRowLabel(index, columns) {
            const label = document.createElement('div');
            label.classList.add('row-ix');
            label.innerText = columns === 1 ? '' : `e_${index + 1}`;
            return label;
        }

        // Helper for numeric multi-inputs (e.g., int-mult, float-mult)
        function addNumericMultiInput(container, key, paramData, numColumns) {
            for (let i = 0; i < numColumns; i++) {
                const inputRow = createInputRow(`e_${i + 1}`);
                inputRow.appendChild(createNumericInput(key, paramData, i, 'min'));
                inputRow.appendChild(createNumericInput(key, paramData, i, 'max'));
                container.appendChild(inputRow);
            }
        }
        // Helper for single numeric inputs (e.g., int, float)
        function addNumericInput(container, key, paramData, overwrite_i=false, i=0) {
            const inputRow = document.createElement('div');
            inputRow.classList.add('input-row');

            inputRow.appendChild(createNumericInput(key, paramData, i, 'min'));
            inputRow.appendChild(createNumericInput(key, paramData, i, 'max'));
            container.appendChild(inputRow);

        }
        // Helper for categorical multi-inputs (e.g., cat-mult)
        function addCategoricalMultiInput(container, key, paramData, numColumns) {
            for (let i = 0; i < numColumns; i++) {
                const inputRow = createInputRow(`e_${i + 1}`);
                inputRow.appendChild(createSelectInput(key, paramData.possible_values, i));
                container.appendChild(inputRow);
            }
        }

        // Helper for single categorical inputs (e.g., cat)
        function addCategoricalInput(container, key, paramData) {
            const inputRow = createInputRow('Select categories');
            inputRow.appendChild(createSelectInput(key, paramData.possible_values));
            container.appendChild(inputRow);
        }

        // Helper for array inputs
        function addArrayInput(container, key, paramData, numColumns) {
            const dimensions = paramData.dimensions;
            for (let i = 0; i < numColumns; i++) {
                const inputRow = createInputRow(`e_${i + 1}`);
                dimensions.forEach((dim, dimIndex) => {
                    inputRow.appendChild(createDimensionLabel(dim));
                    inputRow.appendChild(createNumericInput(key, paramData, i, 'min', dimIndex));
                    inputRow.appendChild(createNumericInput(key, paramData, i, 'max', dimIndex));
                });
                container.appendChild(inputRow);
            }
        }

        // Helper for boolean inputs
        function addBooleanInput(container, key) {
            const inputRow = createInputRow(key, null, 'set (True)', null, null, 1, true);
            //inputRow.appendChild(inputRow);
            container.appendChild(inputRow);
        }

        // Create numeric inputs with min/max handling
        function createNumericInput(keyOrId, paramData = null, index = null, bound = null, dimIndex = null, simpleValue = null, simpleMin = null, simpleMax = null) {
            const input = document.createElement('input');
            input.type = 'number';

            if (paramData) {
                // Use complex structure with key, index, bound, and optional dimIndex
                const key = keyOrId;
                input.id = dimIndex !== null
                    ? `param_${key}_${paramData.dimensions[dimIndex]}_${bound}_${index}`
                    : `param_${key}_${bound}${index !== null ? `_${index}` : ''}`;

                const valueKey = bound === 'min' ? 'min_value' : 'max_value';
                const boundValue = Array.isArray(paramData[valueKey])
                    ? paramData[valueKey][dimIndex]
                    : paramData[valueKey];

                input.value = boundValue || 0;
                input.min = paramData.min_value;
                input.max = paramData.max_value;
            } else {
                // Use simpler structure with id, value, min, and max
                input.id = keyOrId;
                input.value = simpleValue;
                input.min = simpleMin;
                input.max = simpleMax;
            }

            return input;
        }

        // Create dimension labels for array inputs
        function createDimensionLabel(dim) {
            const dimLabel = document.createElement('div');
            dimLabel.classList.add('dim-label');
            dimLabel.innerText = `${dim}:`;
            return dimLabel;
        }

        async function updateFixedParameters(keyList, selData, container_name, append=false){
            const container = document.getElementById(container_name);
            let numColumnsValue;

            if (append==false){
                container.innerHTML = '';  // Clear existing parameters
                const numColumnsInput = document.getElementById('num_electrodes');
                numColumnsValue = numColumnsInput ? numColumnsInput.value : 1;
            }else{
                numColumnsValue = append
            }

            const types = {
                numeric: ['int', 'float'],
                numericMult: ['int-mult', 'float-mult'],
                cat: ['cat'],
                catMult: ['cat-mult'],
                array: ['array'],
                bool: ['boolean']
            };

            keyList.forEach(key => {
                const type = selData[key]['type'];
                const parameterContainer = createParameterContainer();
                const label = createLabel(key, type, selData[key]);
                const inputsContainer = document.createElement('div');
                inputsContainer.classList.add('inputs-container');
                if (types.numericMult.includes(type)) {
                    addNumericMultInputs(inputsContainer, key, selData[key], numColumnsValue);
                } else if (types.numeric.includes(type)) {
                    addSingleNumericInput(inputsContainer, key, selData[key]);
                } else if (types.catMult.includes(type)) {
                    addCatMultInputs(inputsContainer, key, selData[key], numColumnsValue);
                } else if (types.cat.includes(type)) {
                    addSingleCatInput(inputsContainer, key, selData[key]);
                } else if (types.array.includes(type)) {
                    addArrayInputs(inputsContainer, key, selData[key], numColumnsValue);
                } else if (types.bool.includes(type)) {
                    addBooleanInput(inputsContainer, key);
                }

                parameterContainer.appendChild(label);
                parameterContainer.appendChild(inputsContainer);
                container.appendChild(parameterContainer);
            });
        }
        async function updateVariableParameters(keyList, selData, container_name, append=false){
            const container = document.getElementById(container_name);
            let numColumnsValue;
            if (append==false){
                container.innerHTML = '';  // Clear existing parameters
                const numColumnsInput = document.getElementById('num_electrodes');
                numColumnsValue = numColumnsInput ? numColumnsInput.value : 1;
            }else{
                numColumnsValue = append
            }

            const numColumnsInput = document.getElementById('num_electrodes');
            const numColumnsValueVar = numColumnsInput ? numColumnsInput.value : 1;

            const types = {
                numeric: ['int', 'float'],
                numericMult: ['int-mult', 'float-mult'],
                cat: ['cat'],
                catMult: ['cat-mult'],
                array: ['array'],
                bool: ['boolean']
            }

            keyList.forEach(key => {
                const type = selData[key]['type'];
                const paramData = selData[key];
                const parameterContainer = createParameterContainer(key);
                const label = createLabel(key, type, selData[key]);
                const inputsContainer = document.createElement('div');
                inputsContainer.classList.add('inputs-container');
                // Add checkbox for min-max toggle
                const toggleContainer = document.createElement('div');
                const toggleLabel = document.createElement('label');
                toggleLabel.textContent = "Fix value";
                toggleLabel.classList.add('white-text');

                const toggleCheckbox = document.createElement('input');
                toggleCheckbox.type = 'checkbox';
                toggleCheckbox.id = `toggle_${key}`;

                toggleContainer.appendChild(toggleLabel);
                toggleContainer.appendChild(toggleCheckbox);

                // Add event listener to handle toggle
                toggleCheckbox.addEventListener('change', (event) => {
                    const isSingleValue = event.target.checked;
                    inputsContainer.innerHTML = '';  // Clear existing inputs

                    // Determine the input type based on the selection
                    if (isSingleValue) {
                        if (types.numericMult.includes(type)) {
                            addNumericMultInputs(inputsContainer, key, selData[key], numColumnsValue);
                        } else if (types.numeric.includes(type)) {
                            addSingleNumericInput(inputsContainer, key, selData[key]);
                        } else if (types.catMult.includes(type)) {
                            addCatMultInputs(inputsContainer, key, selData[key], numColumnsValue);
                        } else if (types.cat.includes(type)) {
                            addSingleCatInput(inputsContainer, key, selData[key]);
                        } else if (types.array.includes(type)) {
                            addArrayInputs(inputsContainer, key, selData[key], numColumnsValue);
                        } else if (types.bool.includes(type)) {
                            addBooleanInput(inputsContainer, key);
                        }

                    } else {
                        if (types.numericMult.includes(paramData.type)) {
                            addNumericMultiInput(inputsContainer, key, paramData, numColumnsValueVar);
                        } else if (types.numeric.includes(paramData.type)) {
                            if (append==false){
                                addNumericInput(inputsContainer, key, paramData);
                            }else{
                                addNumericInput(inputsContainer, key, paramData, true, numColumnsValue);
                            }
                        } else if (types.catMult.includes(paramData.type)) {
                            addCategoricalMultiInput(inputsContainer, key, paramData, numColumnsValueVar);
                        } else if (types.cat.includes(paramData.type)) {
                            addCategoricalInput(inputsContainer, key, paramData);
                        } else if (types.array.includes(paramData.type)) {
                            addArrayInput(inputsContainer, key, paramData, numColumnsValueVar);
                        } else if (types.bool.includes(paramData.type)) {
                            addBooleanInput(inputsContainer, key);
                        }
                    }
                });
                if (toggleCheckbox.checked) {
                    if (types.numericMult.includes(type)) {
                        addNumericMultInputs(inputsContainer, key, selData[key], numColumnsValue);
                    } else if (types.numeric.includes(type)) {
                        addSingleNumericInput(inputsContainer, key, selData[key]);
                    } else if (types.catMult.includes(type)) {
                        addCatMultInputs(inputsContainer, key, selData[key], numColumnsValue);
                    } else if (types.cat.includes(type)) {
                        addSingleCatInput(inputsContainer, key, selData[key]);
                    } else if (types.array.includes(type)) {
                        addArrayInputs(inputsContainer, key, selData[key], numColumnsValue);
                    } else if (types.bool.includes(type)) {
                        addBooleanInput(inputsContainer, key);
                    }
                } else {
                    if (types.numericMult.includes(paramData.type)) {
                        addNumericMultiInput(inputsContainer, key, paramData, numColumnsValueVar);
                    } else if (types.numeric.includes(paramData.type)) {
                        if (append==false){
                            addNumericInput(inputsContainer, key, paramData);
                        }else{
                            addNumericInput(inputsContainer, key, paramData, true, numColumnsValue);
                        }
                    } else if (types.catMult.includes(paramData.type)) {
                        addCategoricalMultiInput(inputsContainer, key, paramData, numColumnsValueVar);
                    } else if (types.cat.includes(paramData.type)) {
                        addCategoricalInput(inputsContainer, key, paramData);
                    } else if (types.array.includes(paramData.type)) {
                        addArrayInput(inputsContainer, key, paramData, numColumnsValueVar);
                    } else if (types.bool.includes(paramData.type)) {
                        addBooleanInput(inputsContainer, key);
                    }

                }

                parameterContainer.appendChild(label);
                parameterContainer.appendChild(toggleContainer); // Add the toggle checkbox
                parameterContainer.appendChild(inputsContainer);
                container.appendChild(parameterContainer);
            });
        }
        // Function to draw the plot
        function drawPlot() {
            const num_el_container = document.getElementById('num_electrodes')
            if (!num_el_container){ //There are no electrodes in the problem, this plot is not needed.
                return
            }
            const num_el = parseInt(num_el_container.value, 10)
            const centerX = 110
            const canvas = document.getElementById('plotCanvas')
            const height = parseFloat(document.getElementById('param_dia').value)
            const dims = globalData['e_pos']['dimensions']

            const ctx = canvas.getContext('2d');
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the x and y axes
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2); // X axis
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.moveTo(canvas.width / 2, 0); // Y axis
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();

            // Draw the rectangle
            const rectWidth = 250; // Adjust rectangle width
            const rectX = centerX - rectWidth / 2;
            const rectY = (canvas.height / 2) - (height / 2); // Centered vertically

            ctx.fillStyle = 'rgba(100, 150, 200, 0.5)'; // Rectangle color
            ctx.fillRect(rectX, rectY, rectWidth, height);
            ctx.fillStyle = 'red'; // Electrode marker color

            // Plot electrode positions
            for (let n=0; n<=num_el-1; n++){
                let pos = []
                for (let dim in dims) {
                    const el = document.getElementById(`param_e_pos_${dims[dim]}_${n}`);
                    pos.push(parseFloat(el.value))
                }
                const markerX = 10*pos[0] + (canvas.width / 2); // Center the electrodes
                const markerY = -10*pos[1] + (canvas.height/2); // Visually speaking, Positive values are above from the origin
                ctx.fillText('x', markerX, markerY); // Place above rectangle
            }

        }

        function renderJSON(container, data) {
            for (const [key, value] of Object.entries(data)) {
                const keyElement = document.createElement('div');
                keyElement.className = 'json-key';
                keyElement.textContent = `${key}: `;

                const valueElement = document.createElement('span');
                valueElement.className = 'json-value';
                renderJSON(valueElement, value); // Recursive call
                keyElement.appendChild(valueElement);
                div.appendChild(keyElement);

            }
        }
        function updateJSONDisplay() {
            const parameters = collectInputs('sidebar-left');
            const structuredData = restructureParameters(parameters);
            const jsonDisplay = document.getElementById('jsonDisplay');
            jsonDisplay.innerHTML = ''; // Clear previous content
            renderJSON(jsonDisplay, structuredData);
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', fetchExperiments)
        const jsonInputs = document.querySelectorAll('#sidebar-left input');
        jsonInputs.forEach(input => {
            input.addEventListener('input', updateJSONDisplay);
        });


    </script>

</head>
<body>

    <!-- Sidebar -->
    <div class="sidebar" id="sidebar-left">
        <div class="header">
            <h2>Configuration</h2>
        </div>
        <div class="sidebar-frame" id="toggle-btn">
            <button class="toggle-btn" onclick="toggleSidebar()">â˜°</button>
        </div>

        <!-- Toggle button for the sidebar -->
        <!-- Dropdown for selecting experiments -->
        <div class="sidebar-frame" id="exp-selector">
            <select id="experiment" class="styled-select" onchange="experimentChange()">
            <option value="">Select Experiment...</option>
            <!-- Options generated dynamically -->
            </select>
        </div>

        <div id="parameters-header-fixed"></div>
        <div id="parameters-container-num"></div>
        <div id="parameters-container-fixed"></div>
        <div id="parameters-container-fixed-pulse"></div>

        <div id="parameters-header-rest"></div>
        <div id="parameters-container-rest"></div>
        <div id="parameters-container-variable-pulse"></div>

        <div class="experiments-box">

        <button onclick="startExperiment()">Start Experiment</button>
        <button onclick="checkStatus()">Check Status</button>
        <button onclick="stopExperiment()">Stop Experiment</button>

        </div>
        <canvas id="plotCanvas" width="220" height="150"></canvas>

        <div id="json-view" ></div>

    </div>

    <!-- Main content -->
    <div class="content">
        <h1>Live Data Plots</h1>

        <!-- Loading spinner -->
        <div id="spinner" class="spinner"></div>

        <!-- Embedded plot in iframe -->
        <iframe src="http://localhost:{{ port }}/plot" scrolling="no"></iframe>
    </div>

    <div class="sidebar-right" id="sidebar-model">
        <div class="header">
            <h2>Problem config</h2>
        </div>
        <div class="sidebar-frame" id="toggle-btn-right">
            <button class="toggle-btn" onclick="toggleSidebarRight()">â˜°</button>
        </div>
    </div>

</body>
</html>