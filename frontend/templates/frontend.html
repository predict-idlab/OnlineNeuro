<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Data Plots</title>
    <style>
        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #333;
        }

        h1 {
            text-align: center;
            color: #c02a4e;
        }

        /* Main container for content */
        .content {
            margin-left: 380px; /* Width of the sidebar */
            padding: 20px;
            transition: margin-left 0.3s ease;
        }

        /* Sidebar styling */
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 350px;
            height: 100%;
            background-color: #0e0e0e;
            padding: 15px;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
            transition: width 0.3s ease;
            overflow-y: scroll;
        }
        .sidebar-right {
            position: fixed;
            top: 0;
            right: 0; /* Changed from left: 0 to right: 0 */
            width: 250px;
            height: 100%;
            background-color: #0e0e0e;
            padding: 15px;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.2); /* Adjusted the shadow to appear on the left */
            transition: width 0.3s ease;
        }
        .sidebar::-webkit-scrollbar {
            width: 8px; /* Width of the vertical scrollbar */
            height: 8px; /* Height of the horizontal scrollbar */
        }
        /* Track (background of the scrollbar) */
        .sidebar::-webkit-scrollbar-track {
            background: #1e1e1e; /* Dark background color */
            border-radius: 4px; /* Rounded corners */
        }

        /* Thumb (draggable part of the scrollbar) */
        .sidebar::-webkit-scrollbar-thumb {
            background: #555; /* Gray thumb color */
            border-radius: 4px; /* Rounded corners */
        }

        /* Thumb hover (when hovered over) */
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #888; /* Lighter gray when hovered */
        }
        .header {
            display: flex;
            align-items: center;
        }
        .sidebar h2 {
            color: #6b6b6b;
            margin-top: 0;
        }
        .sidebar experiment-box{
            display: block;
            width: 100%;
            margin-bottom: 10px;
            padding: 10px;
        }
        .sidebar button {
            display: block;
            width: 100%;
            margin-bottom: 10px;
            padding: 10px;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }

        .sidebar button:hover {
            background-color: #e0e0e0; /* Button hover effect */
        }

        /* Style for the select dropdown */
        .styled-select {
            background-color:  #333; /* Black background */
            color: white; /* White text */
            border: none;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            width: 100%; /* Full width */
            text-align: left; /* Align text to left */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s ease;
            appearance: none; /* Remove default select arrow for some browsers */
            -webkit-appearance: none; /* Safari/Chrome */
            -moz-appearance: none; /* Firefox */
        }

        /* Optional: Adding an arrow indicator to match the dropdown button feel */
        .styled-select::after {
            content: 'â–¼';
            position: absolute;
            right: 10px;
            pointer-events: none;
        }

        /* Hover effect to match button hover */
        .styled-select:hover {
            background-color: #333; /* Darker background on hover */
        }
        /* Show the dropdown content when the button is clicked */
        .show {
            display: block;
        }

        /* Toggle button for opening/closing sidebar */
        .sidebar-frame{
            /*margin-bottom: 10px;*/
            padding: 10px;
            border-radius: 5px;
        }
        .toggle-btn {
            position: absolute;
            display: block;
            top: 50px;
            left: 20px;
            font-size: 18px;
            background-color: #c02a4e;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        /* When the sidebar is hidden */
        .sidebar-closed {
            width: 0;
            overflow: hidden;
        }
        /*.content-expanded {*/
        /*    margin-left: 30px;*/
        /*}*/
        iframe {
            display: block;
            margin: 20px auto;
            border: none;
            width: 100%;
            height: 400px;
        }
        .parameter-container{
            display:flex;
            align-items:center;
            margin-bottom: 10px;
            justify-content: space-between;
            width: 100%;
        }
        .block-title{
            margin-bottom: 5px;
            font-weight: bold;
            font-size: large;
            color: white;
            text-overflow: ellipsis
        }
        .parameter-label{
            text-align: left;
            margin-right: 8px;
            color: white;
            /*white-space: nowrap;*/
            /*width: 100px;*/
            text-overflow: ellipsis
        }
        .inputs-container {
            display: flex;               /* Use flexbox for the inputs */
            flex-direction: column;      /* Stack input rows vertically */
        }
        .inputs-container input{
            width: 45px;
            margin-right: 3px
        }
        .input-row{
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .row-ix{
            width: 40px;
            /*text-align: left;*/
            font-weight: normal;
            color:white;
            align-content: center;
        }
        .dim-label{
            color:white
        }
        .box {
            width: 100%;
            height: 150px;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
        }
        /* Loading spinner */
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ff3737;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            display: none;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .horizontal-line {
            border: none; /* Remove default border */
            height: 2px; /* Line thickness */
            background-color: #ccc; /* Line color */
            margin-bottom: 8px; /* Space below the line */
        }
        .white-text {
            color: white;
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let globalData
        let optimizableFeatures
        let userDefinedFeatures
        let defaultFeatures

        let globalModelData
        let userDefinedModelFeatures
        let defaultModelFeatures

        //let sortedKeys
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const content = document.querySelector('.content');
            sidebar.classList.toggle('sidebar-closed');
            //content.classList.toggle('content-expanded');
        }
        function toggleSidebarRight() {
            const sidebar = document.querySelector('.sidebar-right');
            const content = document.querySelector('.content');
            sidebar.classList.toggle('sidebar-closed');
            //content.classList.toggle('content-expanded');
        }
        function showSpinner(show) {
            document.getElementById('spinner').style.display = show ? 'block' : 'none';
        }

        function cleanFinalParameters(params) {
            const cleanedParams = {};

            Object.entries(params).forEach(([key, subStruct]) => {
                if (key.startsWith("toggle_")) {
                    return;
                }
                const hasMinMax = 'min_value' in subStruct && 'max_value' in subStruct;
                const values = subStruct.value || false;
                const minValues = subStruct.min_value || false;
                const maxValues = subStruct.max_value || false;

                if (!hasMinMax) {
                    // Scenario 1: Only 'value' key exists
                    const nonNullValues = Array.isArray(values)
                        ? values.filter(val => val !== null)
                        : (values !== null ? [values] : []);
                    if (nonNullValues.length > 0){
                        cleanedParams[key] = nonNullValues
                    }
                } else {
                    // Scenario 2: 'value', 'min_value', and 'max_value' keys exist
                    const valuesIsArray = Array.isArray(values);
                    const minValuesIsArray = Array.isArray(minValues);
                    const maxValuesIsArray = Array.isArray(maxValues);

                    const anyArray = valuesIsArray || minValuesIsArray || maxValuesIsArray
                    const maxLength =  Math.max(valuesIsArray ? values.length : 1,
                        minValuesIsArray ? minValues.length : 1,
                        maxValuesIsArray ? maxValues.length : 1)

                    const filledValues = new Array(maxLength).fill(0);
                    const filledMinValues = new Array(maxLength).fill(0);
                    const filledMaxValues = new Array(maxLength).fill(0);


                    for (let i = 0; i < maxLength; i++) {
                        values && (filledValues[i] = values);
                        minValues && (filledMinValues[i] = minValues);
                        maxValues && (filledMaxValues[i] = maxValues);
                    }

                    cleanedParams[key] = {
                        value: filledValues,
                        min_value: filledMinValues,
                        max_value: filledMaxValues,
                    };
                }
            });

            return cleanedParams;
        }

        function restructureParameters(data) {
            const finalParameters = {};

            Object.entries(data).forEach(([key, value]) => {
                if (typeof value === "string" && !isNaN(value)) {
                    value = parseFloat(value);
                }

                if (key.startsWith('pulse')){
                    if (!finalParameters.pulses) {
                        finalParameters.pulses = [];
                    }
                    // Directly copy the pulse parameters into the pulses array
                    finalParameters.pulses.push(value);
                } else {
                    const cleanedKey = key
                    .replace(/_\d+$/, "") // Remove the index (_n)
                    .replace(/_(min|max)$/, "")    // Remove "_min" or "_max" if present
                    .replace(/_[a-zA-Z]$/, "");    // Remove the last "_x" (it would be a dimension)

                    const typeMatch = key.match(/_(min|max)/); // Check if key ends with "_min" or "_max"
                    const type = typeMatch ? `${typeMatch[1]}_value` : "value"; // Set the key type
                    const ixMatch = key.match(/_(\d+)$/);
                    const ix = ixMatch ? parseInt(ixMatch[1], 10) : null; // Extract the index as an integer, or null if none

                    if (!finalParameters[cleanedKey]) {
                        finalParameters[cleanedKey] = {};
                    }
                    if (!finalParameters[cleanedKey][type]) {
                        finalParameters[cleanedKey][type] = [];
                    }

                    let dimensions
                    if (cleanedKey in globalData) {
                        dimensions = globalData[cleanedKey].dimensions || []
                    } else {
                        dimensions = []
                    }

                    if (dimensions.length === 0) {
                        if (ix !== null) {
                            finalParameters[cleanedKey][type][ix] = value;
                        } else {
                            finalParameters[cleanedKey][type] = value;
                        }
                    } else{
                        const dimensionMatch = key.match(/_([a-zA-Z])_\d+$/); // Matches the dimension (_x_, _y_, etc.)
                        const dimension = dimensionMatch[1];
                        const dimensionIndex = dimensions.indexOf(dimension);

                        if (!finalParameters[cleanedKey][type][dimensionIndex]){
                            finalParameters[cleanedKey][type][dimensionIndex] = []
                        }
                        finalParameters[cleanedKey][type][dimensionIndex][ix] = value;
                    }
                }
            });

            console.log("Final Param", finalParameters);
            const cleanParameters = cleanFinalParameters(finalParameters)
            console.log("Clean Params", cleanParameters)

            Object.entries(defaultFeatures).forEach(([key, value]) => {
                if (!(key in cleanParameters)) {
                    console.log("Key was missing, added,", key)
                    cleanParameters[key] = value;
                }
            });
            cleanParameters['experiment'] = document.getElementById('experiment').value

            return cleanParameters;
        }

        function collectInputs(elementId) {
            const sidebarFrame = document.getElementById(elementId);
            // Object to store the final parameters
            const returnParameters = {};
            const otherParameters = {};

            // Process non-pulse parameters
            const inputs = sidebarFrame.querySelectorAll('input');
            inputs.forEach(input => {
                if (!input.id.startsWith('pulse_')) { // Exclude pulse-related inputs
                    if (input.type === 'checkbox') {
                        otherParameters[input.id] = input.checked; // Boolean for checkboxes
                    } else {
                        otherParameters[input.id] = input.value; // String/number for other inputs
                    }
                }
            });

            const selects = sidebarFrame.querySelectorAll('select');
            selects.forEach(select => {
                if (!select.id.startsWith('pulse_')) { // Exclude pulse-related selects
                    otherParameters[select.id] = select.options[select.selectedIndex].value; // Get selected value
                }
            });

            // Process pulse configurations into a list
            const pulseKeys = Object.keys(globalData).filter(key => key.startsWith('pulse_')); // Filter for pulse keys
            const pulses = [];

            if (pulseKeys){
                // Group pulse configurations by index
                let pulseGrouped = {};

                // Group the pulse keys by their index
                pulseKeys.forEach(pulseKey => {
                    const parts = pulseKey.split('_'); // Split the pulse key like 'pulse_0_I'
                    const pulseIndex = parts[1]; // Extract the index (i.e., 0, 1, 2...)
                    const paramKey = parts.slice(2).join('_'); // Get the rest of the parts as the parameter key (i.e., 'I', 'frq', etc.)
                    if (!pulseGrouped[pulseIndex]) {
                        pulseGrouped[pulseIndex] = {}; // Initialize an empty object for this index if it doesn't exist
                    }
                    pulseGrouped[pulseIndex][paramKey] = globalData[pulseKey]; // Assign the default value to the grouped object
                });

                console.log("Grouped pulse configurations:");
                console.log(pulseGrouped);
                // Now, process each pulse by index and collect the parameters
                Object.keys(pulseGrouped).forEach(pulseIndex => {
                    const pulseConfig = pulseGrouped[pulseIndex];
                    const pulseData = {}; // Container for extracted values

                    // Collect values from inputs in the sidebar
                    Object.keys(pulseConfig).forEach(paramKey => {
                        const simpleInputElement = sidebarFrame.querySelector(`#pulse_${pulseIndex}_${paramKey}`);

                        // Ensure that we initialize the struct for min/max values, even if the simple value is absent
                        if (!pulseData[paramKey]) {
                            pulseData[paramKey] = {}; // Initialize the struct if it doesn't exist yet
                        }
                        if (simpleInputElement) {
                            if (simpleInputElement.type === 'checkbox') {
                                pulseData[paramKey] = {value: simpleInputElement.checked}; // Boolean for checkboxes
                            } else if (simpleInputElement.tagName === 'SELECT') {
                                pulseData[paramKey] = {value: simpleInputElement.options[simpleInputElement.selectedIndex].value}; // Selected value
                            } else {
                                pulseData[paramKey] = {value: simpleInputElement.value}; // Other input types
                            }
                        }

                        // Handle the min and max value separately, if they exist
                        const minInputElement = sidebarFrame.querySelector(`#pulse_${pulseIndex}_${paramKey}_min`);
                        const maxInputElement = sidebarFrame.querySelector(`#pulse_${pulseIndex}_${paramKey}_max`);

                        if (minInputElement) {
                            pulseData[paramKey].min_value = minInputElement.value; // Store min value
                        }
                        if (maxInputElement) {
                            pulseData[paramKey].max_value = maxInputElement.value; // Store max value
                        }
                    });
                    pulses.push(pulseData); // Add the data for this pulse to the list of pulses
                });
            }

            returnParameters.other_parameters = otherParameters

            if (pulses && pulses.length > 0) {
                returnParameters.pulse_parameters = pulses
            }

            return returnParameters
        }

        async function startExperiment() {
            showSpinner(true);
            // Collect all inputs from the "sidebar-frame" div
            let parameters = collectInputs('sidebar-left')

            parameters.other_parameters = restructureParameters(parameters.other_parameters)
            console.log("Restructured params")
            console.log(parameters)

            await createIframes()

            try {
                const response = await fetch('/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(parameters),
                });
                console.log("Package sent")

                const data = await response.json();
                console.log("Response:", data);

            } catch(error) {
                console.error('Error starting the experiment:', error);
            } finally {
                    // Hide the loading spinner
                    showSpinner(false);
            }
        }

        async function checkStatus() {
            const response = await fetch('/status');
            const data = await response.json();
            console.log(data);
        }

        async function stopExperiment() {
            showSpinner(true);
            const response = await fetch('/stop', { method: 'POST' });
            const data = await response.json();
            console.log(data);
            showSpinner(false);
        }

        // Function to display the selected experiment
        // async function fetchExperiments() {
        //     try {
        //         const response = await fetch('/experiments');  // API route that returns JSON
        //         const experiments = await response.json();  // Ensure the response is parsed as JSON
        //         const experimentSelector = document.getElementById('experiment');
        //
        //         // Clear existing options (if any)
        //         experimentSelector.innerHTML = '<option value="">Select Experiment</option>'; // Reset to default option
        //
        //         // Populate the select element with the fetched experiments
        //         experiments.forEach(exp => {
        //             const option = document.createElement('option');
        //             option.value = exp; // Set the value for the option
        //             option.innerText = exp; // Display the experiment name
        //             experimentSelector.appendChild(option); // Append the option to the select
        //         });
        //     } catch (error) {
        //         console.error("Error fetching data:", error);
        //     }
        // }
        async function fetchData(endpoint, selectId, defaultText) {
            try {
                const response = await fetch(`/${endpoint}`); // API route that returns JSON
                const items = await response.json(); // Ensure the response is parsed as JSON
                const selectElement = document.getElementById(selectId);

                // Clear existing options
                selectElement.innerHTML = `<option value="">${defaultText}</option>`; // Reset to default option

                // Populate the select element with the fetched items
                items.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item; // Set the value for the option
                    option.innerText = item; // Display the item name
                    selectElement.appendChild(option); // Append the option to the select
                });
            } catch (error) {
                console.error(`Error fetching ${endpoint}:`, error);
            }
        }
        function sortFeatures(features, dataDic) {
            return features.sort((a, b) => {
                if (dataDic[a].type < dataDic[b].type) return -1;
                if (dataDic[a].type > dataDic[b].type) return 1;
                if (a < b) return -1;
                if (a > b) return 1;

                return 0; // if they are equal
            });
        }
        async function updatePulseParameters(){
            let pulseTypes = Array.from(document.querySelectorAll('[id^="fun_type_"]')).reduce((acc, input) => {
                const match = input.id.match(/_(\d+)$/); // Extract the number at the end of the ID
                if (match) {
                    const number = match[1]; // Get the matched number
                    acc[number] = input.value; // Assign the input value to the corresponding number
                }
                return acc; // Return the accumulator for the next iteration
            }, {});

            if (Object.keys(pulseTypes).length == 0){
                return;
            }
            let configs = [];
            await Promise.all(Object.values(pulseTypes).map(async pt => { // Use Object.values to iterate
                const response = await fetch('/get_fun_parameters', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({function: pt}) // Pass the experiment as JSON in the body
                });
                if (!response.ok) {
                    console.error("Error fetching parameters:", response.statusText);
                    return;
                }
                let this_config = await response.json()
                configs.push(this_config)
                }));

            // Clear out any previous pulse keys in globalData to prevent leftover values
            Object.keys(globalData).forEach(key => {
                if (key.startsWith('pulse_')) {
                    delete globalData[key];
                }
            });

            for (let [i, pulseConfig] of configs.entries()) {
                let pulse_key = `pulse_${i}`
                // globalData[pulse_key] = {}; // Initialize as an empty object
                const prefixedPulseConfig = {};

                Object.keys(pulseConfig).forEach(key => {
                    const prefixedKey = `${pulse_key}_${key}`; // Create the prefixed key
                    globalData[prefixedKey] = pulseConfig[key]; // Store in globalData
                    prefixedPulseConfig[prefixedKey] = pulseConfig[key]; // Map with prefixed keys

                });

                let optPulseFeatures = Object.keys(prefixedPulseConfig).filter(
                    key => prefixedPulseConfig[key]?.optimizable === true
                );
                let fixPulseFeatures = Object.keys(prefixedPulseConfig).filter(
                    key => prefixedPulseConfig[key]?.user_fixed === true
                );

                optPulseFeatures = sortFeatures(optPulseFeatures, prefixedPulseConfig);
                fixPulseFeatures = sortFeatures(fixPulseFeatures, prefixedPulseConfig);

                await updateFixedParameters(fixPulseFeatures, prefixedPulseConfig, 'parameters-container-fixed-pulse', i)
                await updateVariableParameters(optPulseFeatures, prefixedPulseConfig, 'parameters-container-variable-pulse', i)
            }

            Object.keys(pulseTypes).forEach(number => {
                const input = document.getElementById(`fun_type_${number}`);
                input.addEventListener('change', cleanParametersAndUpdate);  // Call the function on change
            });

        }
        async function cleanParametersAndUpdate(){
            // TODO here
            const containerFixedPulse = document.getElementById('parameters-container-fixed-pulse');
            const containerVariablePulse = document.getElementById('parameters-container-variable-pulse');
            containerFixedPulse.innerHTML = ''; //Clear existing parameters
            containerVariablePulse.innerHTML = ''; //Clear existing parameters
            await updatePulseParameters();
        }
        async function updateParameters(){
            await updateFixedParameters(userDefinedFeatures, globalData, 'parameters-container-fixed')
            await updateVariableParameters(optimizableFeatures, globalData , 'parameters-container-rest')
            await updatePulseParameters()
        }

        async function updateModelParameters(){
            await updateFixedParameters(userDefinedModelFeatures, globalModelData, 'parameters-model')
        }
        async function updateElectrodeListeners(){
            const e_pos_inputs = document.querySelectorAll('[id^="e_pos"]');
            // e_pos_inputs.forEach(input => {
            //     input.addEventListener('change', drawPlot);
            // });
            const diameterInput = document.getElementById('dia') || document.getElementById('axon_diameter');
            //TODO uncomment this once the other thing is fixe
            // diameterInput.addEventListener('change', drawPlot);
            // await drawPlot()
        }

        async function addPlotListeners(){
            const experimentSelect = document.getElementById('experiment');
            experimentSelect.addEventListener('change', addPlotListeners);

            const num_electrodes = document.getElementById('num_electrodes');
            if (num_electrodes){
                num_electrodes.addEventListener('change', updateElectrodeListeners);
                await updateElectrodeListeners()
            }

        }
        async function experimentChange(){
            await loadParameters()
            if (globalData.hasOwnProperty('num_electrodes')) {
                await addPlotListeners();
                // TODO uncomment
                //drawPlot();
            } else {
                // Clear the canvas if no electrodes are present
                const canvas = document.getElementById('plotCanvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
                console.log("No electrodes to plot.");
            }
        }
        async function modelChange(){
            await loadModelParameters()
        }
        async function loadParameters() {
            const selectedExperiment = document.getElementById('experiment').value;

            if (selectedExperiment===""){
                globalData = false
                const container = document.getElementById('parameters-container-num');
                const fixedTitle = document.getElementById('parameters-header-fixed');
                const variableTitle = document.getElementById('parameters-header-rest');
                const containerFixed = document.getElementById('parameters-container-fixed');
                const containerVariable = document.getElementById('parameters-container-rest');
                const containerFixedPulse = document.getElementById('parameters-container-fixed-pulse');
                const containerVariablePulse = document.getElementById('parameters-container-variable-pulse');

                container.innerHTML = '';  // Clear existing parameters
                fixedTitle.innerHTML = '';  // Clear existing parameters
                variableTitle.innerHTML = '';  // Clear existing parameters
                containerFixed.innerHTML = '';  // Clear existing parameters
                containerVariable.innerHTML = '';  // Clear existing parameters
                containerFixedPulse.innerHTML = ''; //Clear existing parameters
                containerVariablePulse.innerHTML = ''; //Clear existing parameters

            } else{
                const response = await fetch('/get_parameters', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        type: "problem_parameters",
                        experiment: selectedExperiment}) // Pass the experiment as JSON in the body
                });

                if (!response.ok) {
                    console.error("Error fetching parameters:", response.statusText);
                    return;
                }
                console.log(response)
                globalData = await response.json();

                console.log("Received load")
                console.log(globalData)

                const excludeList = ['num_electrodes'];

                optimizableFeatures = Object.keys(globalData).filter(key => globalData[key].optimizable ===true)
                userDefinedFeatures = Object.keys(globalData).filter(key => globalData[key].user_fixed ===true && !excludeList.includes(key))
                // Non GUI values (see the experiment .json for optimizable/user_fixed both false.)
                defaultFeatures = Object.fromEntries(
                    Object.entries(globalData)
                        .filter(([key, value]) => value.user_fixed === false && value.optimizable === false)
                        .map(([key, value]) => [key, value.value]) // Keep only the 'value' key
                );

                console.log("Default features")
                console.log(defaultFeatures)

                optimizableFeatures = sortFeatures(optimizableFeatures, globalData);
                userDefinedFeatures = sortFeatures(userDefinedFeatures, globalData);

                const container = document.getElementById('parameters-container-num');
                const containerFixed = document.getElementById('parameters-container-fixed');
                const containerVariable = document.getElementById('parameters-container-rest');
                const containerFixedPulse = document.getElementById('parameters-container-fixed-pulse');
                const containerVariablePulse = document.getElementById('parameters-container-variable-pulse');

                const fixedTitle = document.getElementById('parameters-header-fixed');
                const variableTitle = document.getElementById('parameters-header-rest');

                fixedTitle.innerText = '';
                const hrFixed = document.createElement('hr');
                hrFixed.classList.add('horizontal-line');
                fixedTitle.append(hrFixed)

                const titleFix = document.createElement('div');
                titleFix.classList.add('block-title');
                titleFix.innerText = "Fixed parameters"
                fixedTitle.append(titleFix)

                variableTitle.innerText = '';
                const hrVar = document.createElement('hr');
                hrVar.classList.add('horizontal-line');
                variableTitle.append(hrVar)

                const titleVar = document.createElement('div');
                titleVar.classList.add('block-title');
                titleVar.innerText = "Search space"
                variableTitle.append(titleVar)

                if (container) container.innerHTML = '';  // Clear existing parameters
                if (containerFixed) containerFixed.innerHTML = '';
                if (containerVariable) containerVariable.innerHTML = '';
                if (containerFixedPulse) containerFixedPulse.innerHTML = '';
                if (containerVariablePulse) containerVariablePulse.innerHTML = '';

                if (globalData.multiple_sets?.value) { //Extend this so not only num_electrodes?
                    // TODO This would be a hard requirements and needs to be documented.
                    console.log("Data has multiple sets")
                    const row = document.createElement('div');
                    row.classList.add('parameter-container')
                    row.id = 'electrode-sets-row'

                    const label = document.createElement('div');
                    label.classList.add('parameter-label');
                    label.innerText = "Num. of electrodes"

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.id = 'num_electrodes';
                    input.value = globalData.num_electrodes.value;
                    input.min = globalData.num_electrodes.min_value;
                    input.max = globalData.num_electrodes.max_value;
                    input.onchange = updateParameters;

                    row.appendChild(label)
                    row.appendChild(input)

                    container.append(row)
                }
                await updateParameters()

            }
        }

        async function loadModelParameters() {
            const selectedModel = document.getElementById('model').value;
            const container = document.getElementById('parameters-model');
            container.innerHTML = '';  // Clear existing modelparameters
            console.log("here")
            console.log(selectedModel)
            if (selectedModel===""){
                globalModelData = false

            } else{
                const response = await fetch('/get_parameters', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},

                    body: JSON.stringify({
                        type: "model_parameters",
                        model: selectedModel,
                    })
                });
                if (!response.ok) {
                    console.error("Error fetching parameters:", response.statusText);
                    return;
                }
                globalModelData = await response.json();

                console.log("Received load")
                console.log(globalModelData)

                userDefinedModelFeatures = Object.keys(globalModelData).filter(key => globalModelData[key].user_fixed ===true)

                // Non GUI values (see the model .json for non-user_fixed values.)
                defaultModelFeatures = Object.fromEntries(
                    Object.entries(globalModelData)
                        .filter(([key, value]) => value.user_fixed === false)
                        .map(([key, value]) => [key, value.value]) // Keep only the 'value' key
                );

                console.log("Default features")
                console.log(defaultModelFeatures)

                // const fixedTitle = document.getElementById('parameters-header-fixed');
                // const variableTitle = document.getElementById('parameters-header-rest');
                // TODO you are here
                await updateModelParameters()
            }
        }

        // Helper functions
        function createParameterContainer() {
            const container = document.createElement('div');
            container.classList.add('parameter-container');
            return container;
        }

        function createLabel(key, type, data) {
            const label = document.createElement('div');
            label.classList.add('parameter-label');
            if (type === 'boolean' || type === 'cat' || type === 'cat-mult' || type === 'complex') {
                label.innerText = `${key}`;
            } else {
                label.innerText = `${key} [${data.min_value}, ${data.max_value}]`;
            }
            return label;
        }

        function createSelectInput(keyOrId, options, index = null, isMultiple = true) {
            const select = document.createElement('select');
            select.multiple = isMultiple;
            // Determine ID based on input type
            if (index !== null) {
                const key = keyOrId;
                select.id = `${key}_${index}`;
            } else {
                select.id = keyOrId; // Direct ID for simpler cases
            }

            // Populate options
            options.forEach((optionText, i) => {
                const option = document.createElement('option');
                option.value = optionText;
                option.innerText = optionText;
                if (i === 0) option.selected = true; // Select first by default
                select.appendChild(option);
            });

            return select;
        }
        function createNumericInputRow(key, data, index=null) {
            const inputRow = createInputRow(key, false);
            const valueInput = document.createElement('input');
            valueInput.type = 'number';
            valueInput.id = index !== null ? `${key}_${index}` : `${key}`;
            if (data.value !== null) valueInput.value = data.value;
            if (data.min !== null) valueInput.min = data.min;
            if (data.max !== null) valueInput.max = data.max;

            inputRow.appendChild(valueInput);
            return inputRow;
        }

        function addFixedNumericMultipleInputs(container, key, data, columns, index = null) {
            const loopStart = index !== null ? index : 0;
            const loopEnd = index !== null ? index + 1 : columns;

            for (let i = loopStart; i < loopEnd; i++) {
                container.appendChild(createNumericInputRow(key, data, i));
            }
        }
        function addSingleNumericInput(container, key, data, index=null) {
            container.appendChild(createNumericInputRow(key, data, index));
        }

        function addCatMultInputs(container, key, data, columns, index = null) {
            const loopStart = index !== null ? index : 0;
            const loopEnd = index !== null ? index + 1 : columns;

            for (let i = loopStart; i < loopEnd; i++) {
                const inputRow = createSelectRow(key, data.possible_values, i );
                container.appendChild(inputRow);
            }
        }

        function addSingleCatInput(container, key, data, index=null) {
            container.appendChild(createSelectRow(key, data.possible_values, index));
        }

        function addArrayInputs(container, key, data, columns, index=null) {
            for (let i = 0; i < columns; i++) {
                const inputRow = document.createElement('div');
                inputRow.classList.add('input-row');

                const rowLabel = createRowLabel(i);
                inputRow.appendChild(rowLabel);

                data.dimensions.forEach((dim, dimIndex) => {
                    const dimLabel = document.createElement('div');
                    dimLabel.classList.add('dim-label');
                    dimLabel.innerText = `${dim}:`;

                    const valueInput = document.createElement('input');
                    valueInput.type = 'number';
                    valueInput.id = `${key}_${dim}_${i}`;
                    valueInput.value = data.value?.[dimIndex] || 0;
                    if (data.min_value && data.max_value) {
                        valueInput.min = data.min_value[dimIndex];
                        valueInput.max = data.max_value[dimIndex];
                    }
                    inputRow.appendChild(dimLabel);
                    inputRow.appendChild(valueInput);
                });

                container.appendChild(inputRow);
            }
        }

        function createInputRow(key, insertBoolean = false, index=null) {
            const inputRow = document.createElement('div');
            inputRow.classList.add('input-row');

            // Create label for the row, adjusted for index and column count
            const rowLabel = document.createElement('div');
            rowLabel.classList.add('row-ix');

            if (insertBoolean) {
                // Create a checkbox for boolean inputs
                //rowLabel.innerText = "set (True)"
                const booleanInput = document.createElement('input');
                booleanInput.type = 'checkbox';
                booleanInput.id = index=== null? `${key}` : `${key}_${index}`;
                inputRow.appendChild(rowLabel); // Add the label first
                inputRow.appendChild(booleanInput); // Add the checkbox input
            }

            inputRow.appendChild(rowLabel);

            return inputRow;
        }
        function createSelectRow(key, options, index=null) {
            const inputRow = document.createElement('div');
            inputRow.classList.add('input-row');

            const rowLabel = createRowLabel(index);
            const selectInput = document.createElement('select');
            selectInput.id = index !== null ? `${key}_${index}` : `${key}`;

            options.forEach((value) => {
                const option = document.createElement('option');
                option.value = value;
                option.innerText = value;
                selectInput.appendChild(option);
            });
            inputRow.appendChild(rowLabel);
            inputRow.appendChild(selectInput);
            return inputRow;
        }

        function createRowLabel(index) {
            const label = document.createElement('div');
            label.classList.add('row-ix');
            label.innerText = index === 1 ? '' : `e_${index + 1}`;
            return label;
        }

        // Helper for numeric multi-inputs (e.g., int-mult, float-mult)
        function addVariableNumericMultipleInputs(container, key, paramData, index=null) {
            const inputRow = document.createElement('div');
            inputRow.classList.add('input-row');
            inputRow.appendChild(createNumericInput(key, paramData, index, 'min'));
            inputRow.appendChild(createNumericInput(key, paramData, index, 'max'));
            container.appendChild(inputRow);
        }
        // Helper for single numeric inputs (e.g., int, float)
        function addNumericInput(container, key, paramData, index=null) {
            const inputRow = document.createElement('div');
            inputRow.classList.add('input-row');
            inputRow.appendChild(createNumericInput(key, paramData, index, 'min'));
            inputRow.appendChild(createNumericInput(key, paramData, index, 'max'));
            container.appendChild(inputRow);
        }
        // Helper for categorical multi-inputs (e.g., cat-mult)
        function addCategoricalMultiInput(container, key, paramData, numColumns) {
            for (let i = 0; i < numColumns; i++) {
                const inputRow = createInputRow(`e_${i + 1}`);
                inputRow.appendChild(createSelectInput(key, paramData.possible_values, i));
                container.appendChild(inputRow);
            }
        }

        // Helper for single categorical inputs (e.g., cat)
        function addCategoricalInput(container, key, paramData, index=null) {
            const inputRow = createInputRow('Select categories');
            inputRow.appendChild(createSelectInput(key, paramData.possible_values, index));
            container.appendChild(inputRow);
        }

        // Helper for array inputs
        function addArrayInput(container, key, paramData, numColumns) {
            const dimensions = paramData.dimensions;
            for (let i = 0; i < numColumns; i++) {
                const inputRow = createInputRow(`e_${i + 1}`);
                dimensions.forEach((dim, dimIndex) => {
                    inputRow.appendChild(createDimensionLabel(dim));
                    inputRow.appendChild(createNumericInput(key, paramData, i, 'min', dimIndex));
                    inputRow.appendChild(createNumericInput(key, paramData, i, 'max', dimIndex));
                });
                container.appendChild(inputRow);
            }
        }

        // Helper for boolean inputs
        function addBooleanInput(container, key, index) {
            const inputRow = createInputRow(key, true);
            //inputRow.appendChild(inputRow);
            container.appendChild(inputRow);
        }
        function addComplexInput(container, key, paramData, index){
            //inputsContainer, key, selData[key], numColumnsValue
            const inputRow = document.createElement('div');
            inputRow.classList.add('input-row')
            const input = document.createElement('input');
            input.type = 'text'
            input.name = 'param_${key}'
            if (paramData.value !== null) {input.placeholder = paramData.value} else {input.placeholder = '${key}'};

            inputRow.appendChild(input)
            container.appendChild(inputRow)
        }

        // Create numeric inputs with min/max handling
        //key, paramData, i, 'min')
        function createNumericInput(keyOrId, paramData = null, index = null, bound = null, dimIndex = null, simpleValue = null, simpleMin = null, simpleMax = null) {
            const input = document.createElement('input');
            input.type = 'number';

            if (paramData) {
                // Use complex structure with key, index, bound, and optional dimIndex
                const key = keyOrId;
                input.id = dimIndex !== null
                    ? `${key}_${paramData.dimensions[dimIndex]}_${bound}_${index}`
                    : `${key}_${bound}${index !== null ? `_${index}` : ''}`;

                const valueKey = bound === 'min' ? 'min_value' : 'max_value';
                const boundValue = Array.isArray(paramData[valueKey])
                    ? paramData[valueKey][dimIndex]
                    : paramData[valueKey];

                input.value = boundValue || 0;
                input.min = paramData.min_value;
                input.max = paramData.max_value;
            } else {
                // Use simpler structure with id, value, min, and max
                input.id = keyOrId;
                input.value = simpleValue;
                input.min = simpleMin;
                input.max = simpleMax;
            }

            return input;
        }

        // Create dimension labels for array inputs
        function createDimensionLabel(dim) {
            const dimLabel = document.createElement('div');
            dimLabel.classList.add('dim-label');
            dimLabel.innerText = `${dim}:`;
            return dimLabel;
        }

        async function updateFixedParameters(keyList, selData, container_name, append=false, index=null){
            const container = document.getElementById(container_name);
            const numColumnsInput = document.getElementById('num_electrodes');
            const numColumnsValue = append === false
                ? (numColumnsInput ? numColumnsInput.value : 0)
                : null;

            if (!append) container.innerHTML = ''; // Clear existing parameters

            const inputActions = {
                'int-mult': addFixedNumericMultipleInputs,
                'float-mult': addFixedNumericMultipleInputs,
                'cat-mult': addCatMultInputs,
                'int': addSingleNumericInput,
                'float': addSingleNumericInput,
                'cat': addSingleCatInput,
                'array': addArrayInputs,
                'boolean': addBooleanInput,
                //'complex-mult' : addComplexMultipleInputs
                'complex': addComplexInput,

            };

            keyList.forEach(key => {
                const type = selData[key]['type'];
                const parameterContainer = createParameterContainer();
                const label = createLabel(key, type, selData[key]);
                const inputsContainer = document.createElement('div');
                inputsContainer.classList.add('inputs-container');

                const action = inputActions[type];
                if (action) {
                    action(inputsContainer, key, selData[key], numColumnsValue);
                } else {
                    console.warn(`Unknown type: ${type}`);
                }

                parameterContainer.appendChild(label);
                parameterContainer.appendChild(inputsContainer);
                container.appendChild(parameterContainer);
            });
        }
        async function updateVariableParameters(keyList, selData, container_name, append=false){
            const container = document.getElementById(container_name);
            const numColumnsInput = document.getElementById('num_electrodes');

            const numColumnsValue = append === false
                ? (numColumnsInput ? numColumnsInput.value : 0)
                : null;

            if (!append) container.innerHTML = ''; // Clear existing parameters

            const inputActions = {
                'int-mult': addVariableNumericMultipleInputs,
                'float-mult': addVariableNumericMultipleInputs,
                'int': addNumericInput,
                'float': addNumericInput,
                'cat-mult': addCategoricalMultiInput,
                'cat': addCategoricalInput,
                'array': addArrayInput,
                'boolean': addBooleanInput
            };

            const fixedAction = {
                'int-mult': addFixedNumericMultipleInputs,
                'float-mult': addFixedNumericMultipleInputs,
                'int': addSingleNumericInput,
                'float': addSingleNumericInput,
                'cat-mult': addCatMultInputs,
                'cat': addSingleCatInput,
                'array': addArrayInputs,
                'boolean': addBooleanInput
            };

            keyList.forEach(key => {
                const type = selData[key]['type'];
                const paramData = selData[key];
                const parameterContainer = createParameterContainer(key);
                const label = createLabel(key, type, selData[key]);
                const inputsContainer = document.createElement('div');
                inputsContainer.classList.add('inputs-container');

                // Add checkbox for min-max toggle
                const toggleContainer = document.createElement('div');
                const toggleLabel = document.createElement('label');
                toggleLabel.textContent = "Fix value";
                toggleLabel.classList.add('white-text');

                const toggleCheckbox = document.createElement('input');
                toggleCheckbox.type = 'checkbox';

                toggleCheckbox.id = `toggle_${key}`;

                toggleContainer.appendChild(toggleLabel);
                toggleContainer.appendChild(toggleCheckbox);

                // Add event listener to handle toggle
                toggleCheckbox.addEventListener('change', (event) => {
                    const isFixed = event.target.checked;
                    inputsContainer.innerHTML = ''; // Clear existing inputs
                    const action = isFixed ? fixedAction[type] : inputActions[type];

                    if (action) {
                        action(inputsContainer, key, paramData);
                    } else {
                        console.warn(`Unknown type: ${type}`);
                    }
                });

                const initialAction = toggleCheckbox.checked ? fixedAction[type] : inputActions[type];

                if (initialAction) {
                    initialAction(inputsContainer, key, paramData);
                } else {
                    console.warn(`Unknown type: ${type}`);
                }

                parameterContainer.appendChild(label);
                parameterContainer.appendChild(toggleContainer); // Add the toggle checkbox
                parameterContainer.appendChild(inputsContainer);
                container.appendChild(parameterContainer);
            });
        }
        // Function to draw the plot
        function drawPlot() {
            const num_el_container = document.getElementById('num_electrodes')
            if (!num_el_container){ //There are no electrodes in the problem, this plot is not needed.
                return
            }
            const num_el = parseInt(num_el_container.value, 10)
            const centerX = 110
            const canvas = document.getElementById('plotCanvas')

            let height
            if (globalData['name'].startsWith("axonsim")){
                height = parseFloat(document.getElementById('dia').value)
            }
            else if (globalData['name'].startsWith("cajal")){
                height = parseFloat(document.getElementById('axon_diameter').value)
            }
            else{
                console.error("The input is not valid")
            }

            const dims = globalData['e_pos']['dimensions']
            const ctx = canvas.getContext('2d');
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the x and y axes
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2); // X axis
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.moveTo(canvas.width / 2, 0); // Y axis
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();

            // Draw the rectangle
            const rectWidth = 250; // Adjust rectangle width
            const rectX = centerX - rectWidth / 2;
            const rectY = (canvas.height / 2) - (height / 2); // Centered vertically

            ctx.fillStyle = 'rgba(100, 150, 200, 0.5)'; // Rectangle color
            ctx.fillRect(rectX, rectY, rectWidth, height);
            ctx.fillStyle = 'red'; // Electrode marker color

            // Plot electrode positions
            for (let n=0; n<=num_el-1; n++){
                let pos = []
                for (let dim in dims) {
                    const el = document.getElementById(`e_pos_${dims[dim]}_${n}`);
                    pos.push(parseFloat(el.value))
                }
                const markerX = 10*pos[0] + (canvas.width / 2); // Center the electrodes
                const markerY = -10*pos[1] + (canvas.height/2); // Visually speaking, Positive values are above from the origin
                ctx.fillText('x', markerX, markerY); // Place above rectangle
            }

        }
        function draw3DPlot() {
            const num_el_container = document.getElementById('num_electrodes')
            if (!num_el_container) { // There are no electrodes in the problem, this plot is not needed.
                return
            }
            const num_el = parseInt(num_el_container.value, 10)
            const centerX = 110
            const canvas = document.getElementById('plotCanvas')
            const height = parseFloat(document.getElementById('axon_diameter').value)
            const dims = globalData['e_pos']['dimensions']

            // Create the scene and camera
            const scene = new THREE.Scene()
            const camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000)
            const renderer = new THREE.WebGLRenderer({ canvas: canvas })
            renderer.setSize(canvas.width, canvas.height)

            // Set camera position
            camera.position.z = 500

            // Add axes for reference
            const axesHelper = new THREE.AxesHelper(100)
            scene.add(axesHelper)

            // Draw the rectangle as a 3D box
            const geometry = new THREE.BoxGeometry(250, height, 10) // Width, height, depth
            const material = new THREE.MeshBasicMaterial({ color: 0x6496c8, transparent: true, opacity: 0.5 })
            const rect = new THREE.Mesh(geometry, material)
            scene.add(rect)

            // Center the rectangle
            rect.position.set(centerX, 0, 0) // Adjust rectangle position

            // Create a material for the electrode markers
            const electrodeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 })

            // Plot electrode positions
            for (let n = 0; n <= num_el - 1; n++) {
                let pos = []
                for (let dim in dims) {
                    const el = document.getElementById(`e_pos_${dims[dim]}_${n}`);
                    pos.push(parseFloat(el.value))
                }
                const electrodeGeometry = new THREE.SphereGeometry(5, 32, 32) // Small sphere for electrodes
                const electrode = new THREE.Mesh(electrodeGeometry, electrodeMaterial)

                // Set electrode position (scaled to fit canvas)
                electrode.position.set(10 * pos[0] + centerX, -10 * pos[1], 10 * pos[2])

                scene.add(electrode)
            }

            // Rendering loop
            function animate() {
                requestAnimationFrame(animate)
                renderer.render(scene, camera)
            }

            animate() // Start animation loop
        }
        function renderJSON(container, data) {
            for (const [key, value] of Object.entries(data)) {
                const keyElement = document.createElement('div');
                keyElement.className = 'json-key';
                keyElement.textContent = `${key}: `;

                const valueElement = document.createElement('span');
                valueElement.className = 'json-value';
                renderJSON(valueElement, value); // Recursive call
                keyElement.appendChild(valueElement);
                div.appendChild(keyElement);

            }
        }
        function updateJSONDisplay() {
            const parameters = collectInputs('sidebar-left');
            const structuredData = restructureParameters(parameters);
            const jsonDisplay = document.getElementById('jsonDisplay');
            jsonDisplay.innerHTML = ''; // Clear previous content
            renderJSON(jsonDisplay, structuredData);
        }
        async function fetchExperimentsAndModels() {
            await fetchData('experiments', 'experiment', 'Select Experiment');
            await fetchData('models', 'model', 'Select Model');
        }

    </script>
    <script>
        document.addEventListener('DOMContentLoaded', fetchExperimentsAndModels)
        const jsonInputsLeft = document.querySelectorAll('#sidebar-left input');
        jsonInputsLeft.forEach(input => {
            input.addEventListener('input', updateJSONDisplay);
        });
        const jsonInputsRight = document.querySelectorAll('#sidebar-right input');
        jsonInputsRight.forEach(input => {
            input.addEventListener('input', updateJSONDisplay);
        });

    </script>

    <script>
        // Function to create and append iFrames
        async function createIframes() {
            await removeIframes()
            const iframeContainer = document.getElementById('iframeContainer');

            // Example list of iFrame configurations
            const iframeConfigs = [
                { id: 'mainPlot', src: 'http://localhost:{{ port }}/plot?type=plotly' },
                { id: 'scatterPlot', src: 'http://localhost:{{ port }}/plot?type=contour' }
            ];

            iframeConfigs.forEach(config => {
                if (!document.getElementById(config.id)) {
                    const iframe = document.createElement('iframe');
                    iframe.id = config.id;
                    iframe.src = config.src;
                    iframe.style.width = '100%';
                    //iframe.style.height = '500px';
                    iframeContainer.appendChild(iframe);
                }
            });
        }

        // Function to remove (or hide) iFrames
        function removeIframes() {
            const iframeContainer = document.getElementById('iframeContainer');
            const existingIframes = iframeContainer.querySelectorAll('iframe');
            existingIframes.forEach(iframe => {
                iframe.remove(); // Alternatively, use iframe.style.display = 'none'; to hide instead of removing
            });
        }
        // Attach event listeners to buttons
        // document.getElementById('startButton').addEventListener('click', createIframes);
        // document.getElementById('stopButton').addEventListener('click', removeIframes);
  </script>

</head>
<body>

    <!-- Sidebar -->
    <div class="sidebar" id="sidebar-left">
        <div class="header">
            <h2>Configuration</h2>
        </div>
        <div class="sidebar-frame" id="toggle-btn">
            <button class="toggle-btn" onclick="toggleSidebar()">â˜°</button>
        </div>

        <!-- Toggle button for the sidebar -->
        <!-- Dropdown for selecting experiments -->
        <div class="sidebar-frame" id="exp-selector">
            <select id="experiment" class="styled-select" onchange="experimentChange()">
            <option value="">Select Experiment...</option>
            <!-- Options generated dynamically -->
            </select>
        </div>

        <div id="parameters-header-fixed"></div>
        <div id="parameters-container-num"></div>
        <div id="parameters-container-fixed"></div>
        <div id="parameters-container-fixed-pulse"></div>

        <div id="parameters-header-rest"></div>
        <div id="parameters-container-rest"></div>
        <div id="parameters-container-variable-pulse"></div>

        <div class="experiments-box">

        <button id="startExpermient" onclick="startExperiment()">Start Experiment</button>
        <button id="checkStatus" onclick="checkStatus()">Check Status</button>
        <button id="stopExpermient" onclick="stopExperiment()">Stop Experiment</button>

        </div>
        <canvas id="plotCanvas" width="150" height="150"></canvas>

        <div id="json-view" ></div>

    </div>

    <!-- Main content -->
    <div id="spinner" class="spinner"></div>

    <div class="content" id="iframeContainer"></div>
    <div class="sidebar-right" id="sidebar-right">
        <div class="header">
            <h2>Problem config</h2>
        </div>
        <div class="sidebar-frame" id="toggle-btn-right">
            <button class="toggle-btn" onclick="toggleSidebarRight()">â˜°</button>
        </div>
        <div class="sidebar-frame" id="model-selector">
            <select id="model" class="styled-select" onchange="modelChange()">
            <option value="">Select Model...</option>
            <!-- Options generated dynamically -->
            </select>
        </div>
        <div id="parameters-model"></div>
    </div>

</body>
</html>
